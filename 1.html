<!DOCTYPE html>
<html lang="fr">
<head>
	<link rel="manifest" href="manifest.json">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OI</title>
	<link rel="icon" href="favicon.ico" sizes="any" type="image/png">
    <link rel="icon" href="favicon.ico" type="image/svg+xml">
    <link rel="apple-touch-icon" href="favicon.ico">
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Saira+Stencil+One:wght@400&display=swap" rel="stylesheet">
    <!-- Utilisation des Material Symbols Outlined -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />
    <style>
       :root {
            --bg-body: #000000; --bg-container: #000000; --bg-interactive: #2a2a2a;
            --text-primary: #e0e0e0; --text-secondary: #95a5a6; --border-color: #444444;
            --accent-blue: #5b9bd5; --accent-hover: #4a7aa5; --danger-red: #be1b09;
            --success-green: #259654;
            --trash-color: #6c757d;
        }
        body.light-mode {
            --bg-body: #d2d3d59c; --bg-container: #cdcccc; --bg-interactive: #ffffff;
            --text-primary: #212529; --text-secondary: #212529; --accent-blue: #002e91;
            --success-green: #13bf00;
            --border-color: #000000;
            --trash-color: #000000;
        }
		#main-footer { width: 100%;  text-align: center; margin-top: 2rem;  padding: 1rem; color: #5b9bd5; font-size: 0.75rem;border-top: 1px solid #5b9bd5;}
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { font-size: 16px; }
        /* Augmentation du padding-bottom pour le dock */
        body { 
            font-family: 'Oswald', sans-serif; background-color: var(--bg-body); color: var(--text-primary); 
            line-height: 1.6; padding: 10px; padding-bottom: 90px; /* Espace pour le dock */
            transition: background-color 0.3s, color 0.3s; 
        }
        .container { 
            width: 100%; max-width: 800px; margin: auto; 
            background: var(--bg-container); padding: 20px; 
            border-radius: 8px; border: 1px solid var(--border-color); 
            position: relative; 
        }
        h1 { 
            font-size: 2.2em; margin-bottom: 20px; color: var(--accent-blue); 
            font-family: 'Saira+Stencil+One', sans-serif; text-align: center; 
            letter-spacing: 1.5px; font-weight: 400; 
        }
        h2 { font-size: 1.4em; color: var(--accent-blue); border-bottom: 2px solid var(--accent-blue); padding-bottom: 10px; margin-top: 20px; }
        h3 { font-size: 1.1em; color: var(--text-primary); margin-top: 15px; margin-bottom: 10px; }
        h4 { font-size: 1.0em; color: var(--text-secondary); margin-top: 10px; margin-bottom: 5px; }
        
        /* Suppression du style du bouton de thème dans l'en-tête */
        #darkModeToggle.header-button { display: none; }

        .wizard-progress { 
            display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; 
            margin-bottom: 25px; list-style-type: none; padding: 0; 
        }
        .wizard-progress-step {
            flex-grow: 1; padding: 8px 6px; text-align: center; font-size: 0.7em;
            color: var(--text-secondary); background-color: var(--bg-interactive);
            border: 1px solid var(--border-color); border-radius: 6px; cursor: pointer;
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
            min-width: 50px;
        }
        @media (min-width: 600px) {
             .wizard-progress-step {
                font-size: 0.85em;
                padding: 8px 12px;
             }
        }
        
        .wizard-progress-step:hover { background-color: var(--bg-body); }
        .wizard-progress-step.completed { border-color: var(--accent-blue); color: var(--accent-blue); }
        .wizard-progress-step.active {
            color: white; background-color: var(--accent-blue);
            border-color: var(--accent-blue); font-weight: 500;
        }
        .wizard-step { display: none; animation: fadeIn 0.5s; }
        .wizard-step.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .wizard-nav { display: flex; flex-wrap: wrap; justify-content: space-between; margin-top: 30px; border-top: 1px solid var(--border-color); padding-top: 20px; gap: 10px; }
        .wizard-nav-btn { flex-grow: 1; padding: 14px 20px; border: none; border-radius: 5px; cursor: pointer; font-family: 'Oswald', sans-serif; font-size: 1.1em; min-height: 48px;}

        #prevBtn { background-color: var(--bg-interactive); color: var(--text-primary); border: 1px solid var(--border-color); }
        #nextBtn { background-color: var(--accent-blue); color: white; }
        #previewBtn { background-color: var(--success-green); color: white; }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: var(--text-secondary); }
        input, textarea, select { width: 100%; padding: 14px; margin-bottom: 15px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 1.1rem; background-color: var(--bg-interactive); color: var(--text-primary); font-family: 'Oswald', sans-serif; min-height: 48px;}
        textarea { min-height: 120px; }
        
        .dynamic-list-item { 
            display: flex; flex-direction: column; align-items: stretch;
            gap: 10px; margin-bottom: 10px; 
        }

        @media (min-width: 480px) {
            .wizard-step .dynamic-list-item:has(#date_naissance) {
                flex-direction: row;
            }
            .wizard-step .dynamic-list-item:has(#date_naissance) input {
                width: auto;
            }
        }
        
        button.add-btn, button.remove-btn { min-height: 44px; }
        
        button.add-btn { background-color: #27ae60; color: white; border: none; border-radius: 4px; padding: 8px 12px; margin-top: 5px; cursor: pointer; }
        button.remove-btn { background-color: var(--danger-red); color: white; border: none; border-radius: 4px; padding: 5px 10px; font-size: 14px; cursor: pointer; }
        
        .chip-container {
            display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px; padding: 5px 0;
            border-bottom: 1px dashed var(--border-color);
        }
        .chip-btn {
            background-color: var(--bg-interactive); color: var(--text-secondary); 
            border: 1px solid var(--border-color); padding: 8px 12px; border-radius: 20px;
            cursor: pointer; transition: all 0.2s; font-family: 'Oswald', sans-serif;
            font-size: 0.9em; flex-shrink: 0;
        }
        .chip-btn.selected {
            background-color: var(--accent-blue); color: white; border-color: var(--accent-blue);
        }
        .chip-btn:hover:not(.selected) {
            background-color: var(--bg-body);
        }

        .collapsible-container { background-color: var(--bg-interactive); border: 1px solid var(--border-color); border-radius: 5px; margin-bottom: 15px; }
        .collapsible-header { cursor: pointer; padding: 15px; display: flex; justify-content: space-between; align-items: center; }
        .collapsible-header h3 { font-size: 1.2em; margin: 0; color: var(--text-primary); }
        .collapsible-header .material-symbols-outlined { transition: transform 0.3s; }
        .collapsible-container.open .collapsible-header .material-symbols-outlined { transform: rotate(180deg); }
        .collapsible-content { padding: 0 15px; max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out, padding 0.3s ease-out; }
        .collapsible-container.open .collapsible-content { max-height: 4000px; padding-top: 10px; padding-bottom: 15px; }
        
        .articulation-composition-display p { margin-bottom: 5px; }
        .articulation-composition-display strong { color: var(--accent-blue); }

        .photo-input, #pdfBackgroundInput { display: none; }
        .file-upload-label { background-color: var(--accent-blue); color: white !important; padding: 10px 14px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; font-family: 'Oswald', sans-serif; font-weight: normal; display: inline-block; text-align: center; flex-shrink: 0; }
        .file-upload-label:hover { background-color: var(--accent-hover); }
        .image-preview { max-width: 150px; max-height: 100px; margin-top: 10px; border-radius: 4px; border: 1px solid var(--border-color); }
        .image-preview-item {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .image-preview-item .remove-btn, .image-preview-item .add-btn {
            font-size: 0.8em; padding: 2px 6px; min-height: unset;
        }
        .photo-display-area {
            display: flex; flex-wrap: wrap; gap: 10px; padding: 10px; min-height: 70px;
            border: 1px dashed var(--border-color); border-radius: 5px; align-content: flex-start;
        }
        .photo-display-area .image-preview {
            margin: 0;
        }

        .draggable { cursor: grab; user-select: none; }
        .draggable.dragging { opacity: 0.5; cursor: grabbing; }
        
        #patracdvr_container, #unassigned_members_container { 
            display: flex; flex-wrap: wrap; gap: 10px; padding: 10px; min-height: 70px; 
            border: 1px dashed var(--border-color); border-radius: 5px; align-content: flex-start;
        }
        
        .patracdvr-member-btn { 
            background-color: var(--bg-body); border: 2px solid var(--border-color); color: var(--text-primary); 
            padding: 8px 12px; border-radius: 5px; text-align: center; font-family: 'Oswald', sans-serif; 
            cursor: pointer; transition: all 0.2s; min-height: 56px; display: flex; flex-direction: column; justify-content: center;
        }
        .patracdvr-member-btn:hover { border-color: var(--accent-hover); }
        .patracdvr-member-btn.member-active { border-color: var(--accent-blue); box-shadow: 0 0 8px var(--accent-blue); }
        .patracdvr-member-btn .trigramme { font-weight: bold; }
        .patracdvr-member-btn .fonction { font-size: 0.8em; color: var(--text-secondary); display: block; }
        
        .patracdvr-vehicle-row {
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 8px;
            padding-top: 28px; 
            border: 1px solid var(--border-color);
            background-color: var(--bg-body);
            border-radius: 5px;
            min-height: 56px; 
            min-width: 100px; 
            width: auto; 
            align-items: flex-start;
            justify-content: flex-start;
        }
        .patracdvr-vehicle-row .patracdvr-members-container {
            border: 1px dashed var(--border-color);
            border-radius: 4px;
            min-height: 40px;
            width: 100%;
            padding: 5px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            align-content: flex-start;
        }
        .vehicle-header {
            position: absolute;
            top: 4px;
            left: 8px;
            right: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .vehicle-name {
            font-size: 0.9em;
            font-weight: bold;
            color: var(--accent-blue);
        }
        .vehicle-header .remove-btn {
            padding: 2px 5px;
            min-height: unset;
            font-size: 12px;
        }
        
        /* Modals: Simplified */
        #quickEditModal { color: var(--text-primary); background: var(--bg-container); width: 100vw; max-width: 100vw; height: 100vh; max-height: 100vh; margin: 0; border: none; border-radius: 0; padding: 15px; }
        #quickEditModal::backdrop { background: rgba(0, 0, 0, 0.85); }
        #quickEditModal .modal-form { display: flex; flex-direction: column; height: 100%; }
        #quickEditModal .modal-content { flex: 1 1 auto; overflow-y: auto; padding: 0 5px; }
        #quickEditModal .modal-actions { flex-shrink: 0; display: flex; justify-content: space-between; gap: 10px; margin-top: 20px; }
        #quickEditModal .modal-actions button { flex: 1; }
        #quick_modal_closeBtn { background-color: var(--bg-interactive); color: var(--text-primary); border: 1px solid var(--border-color); }

        #quickEditPanel { 
            padding: 15px; border: 1px solid var(--border-color); border-radius: 5px; margin-top: 20px; background-color: var(--bg-body); 
            display: flex;
            flex-direction: column;
        }
        #quickEditPanel h4 { margin-top: 0; }
        #quickEditPanel h4 #selectedMemberTrigramme { color: var(--accent-blue); }
        .quick-edit-content .quick-edit-tab-panel { display: none; }
        .quick-edit-options { display: flex; flex-wrap: wrap; gap: 8px; }
        .quick-edit-btn { background-color: var(--bg-interactive); border: 1px solid var(--border-color); color: var(--text-secondary); padding: 6px 10px; border-radius: 4px; cursor: pointer; font-family: 'Oswald', sans-serif; font-size: 0.9em; transition: all 0.2s; }
        .quick-edit-btn:hover { border-color: var(--accent-hover); color: var(--text-primary); }
        .quick-edit-btn.selected { background-color: var(--accent-blue); color: white; border-color: var(--accent-blue); }
        #quickEditModal .quick-edit-category { margin-bottom: 20px; }
        #quickEditModal .quick-edit-category h5 { font-size: 1.1em; color: var(--text-secondary); margin-bottom: 10px; border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }

        /* Styles de la corbeille */
        #trashCan {
            margin-top: 20px;
            padding: 20px;
            border: 3px dashed var(--trash-color);
            border-radius: 10px;
            text-align: center;
            color: var(--trash-color);
            transition: all 0.3s ease-in-out;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
        }
        #trashCan.drag-over {
            border-color: var(--danger-red);
            background-color: rgba(192, 57, 43, 0.1);
            color: var(--danger-red);
        }
        #trashCan .material-symbols-outlined {
            font-size: 40px;
            margin-bottom: 5px;
        }

        #annotationModal { width: 100vw; max-width: 100vw; height: 100vh; max-height: 100vh; margin: 0; border: none; border-radius: 0; padding: 0; overflow: hidden; }
        #annotationModal::backdrop { background: rgba(0,0,0,0.85); }
        .annotation-wrapper { display: flex; flex-direction: column; height: 100%; }
        .annotation-toolbar { order: 2; display: flex; flex-direction: column; gap: 10px; padding: 10px; background: var(--bg-body); border-top: 1px solid var(--border-color); flex-shrink: 0; }
        .toolbar-main-tools, .toolbar-contextual-tools { 
            display: flex; 
            flex-wrap: nowrap; 
            gap: 10px; 
            overflow-x: auto; 
            padding-bottom: 5px; 
        }
        .toolbar-main-tools::-webkit-scrollbar, .toolbar-contextual-tools::-webkit-scrollbar { height: 4px; }
        .toolbar-main-tools::-webkit-scrollbar-thumb, .toolbar-contextual-tools::-webkit-scrollbar-thumb { background: var(--border-color); }
        .tool-btn { 
            padding: 10px; font-family: 'Oswald', sans-serif; border: 1px solid var(--border-color); 
            background: var(--bg-interactive); color: var(--text-primary); cursor: pointer; border-radius: 4px; 
            display: flex; align-items: center; justify-content: center; flex-direction: column; gap: 4px; 
            flex-shrink: 0; min-width: 80px; 
        }
        .tool-btn .material-symbols-outlined { font-size: 28px; }
        .tool-btn.active { background: var(--accent-blue); color: white; border-color: var(--accent-blue); }
        .tool-controls, #contextual_tools { display: none; }
        .tool-controls.active, #contextual_tools.active { 
            display: flex; flex-wrap: wrap; align-items: center; gap: 10px; padding: 10px; 
            border: 1px dashed var(--border-color); border-radius: 4px; 
            overflow-x: auto;
            max-width: 100%;
        }
        .tool-controls label { margin-bottom: 0; }
        .tool-controls input { margin-bottom: 0; padding: 8px; max-width: 150px; } 
        #edit_text_btn { display: none; }
        #contextual_tools.active.location-selected #edit_text_btn { display: flex; }
        .annotation-actions { display: flex; justify-content: space-around; gap: 10px; padding-top: 10px; border-top: 1px solid var(--border-color); margin-top: 10px;}
        .annotation-actions button { flex: 1; justify-content: center; }
        .annotation-canvas-container { order: 1; flex-grow: 1; display: flex; align-items: center; justify-content: center; background: #000; padding: 5px; overflow: auto; min-height: 0; }
        #annotationCanvas { max-width: 100%; max-height: 100%; object-fit: contain; }

         #presentationModal {
            width: 95vw; max-width: 1200px; height: 95vh; 
            background: var(--bg-body); color: var(--text-primary); 
            border: 1px solid var(--accent-blue); border-radius: 8px; 
            padding: 20px; overflow: hidden;
        }
        #presentationModal::backdrop { background: rgba(0, 0, 0, 0.85); }

        #presentation-content {
            height: calc(100% - 60px); 
            overflow-y: auto; 
            padding-right: 15px; 
        }
        .modal-actions-pdf {
            display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px; 
            flex-shrink: 0;
        }
        .modal-actions-pdf button { width: auto; }
        .modal-actions-pdf #downloadPdfBtn { flex: 1; max-width: 250px; background-color: var(--success-green); }

        .coherence-alert {
            background-color: #331f1f;
            color: #c0392b;
            border: 1px solid #c0392b;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-weight: bold;
            display: flex;
            align-items: center;
        }
        .coherence-alert .material-symbols-outlined {
            margin-right: 10px;
            font-size: 24px;
        }
        
        /* Styles du Dock Flottant (Ajout) */
        .dock-menu { 
            position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); 
            display: flex; gap: 10px; padding: 10px; z-index: 1000; 
            background-color: rgba(30, 30, 30, 0.7); /* Fond semi-transparent foncé */
            border: 1px solid var(--border-color); 
            border-radius: 35px; backdrop-filter: blur(10px); 
            transition: all 0.3s ease-in-out; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }
        .dock-menu-item { 
            display: flex; align-items: center; justify-content: center; 
            background-color: var(--bg-container); color: var(--text-primary); 
            border: 1px solid var(--border-color); 
            border-radius: 50%; width: 50px; height: 50px; 
            font-size: 28px; cursor: pointer; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
            transition: all 0.2s; text-decoration: none; flex-shrink: 0; 
        }
        .dock-menu-item:hover { transform: scale(1.1); }

        /* Styles spécifiques au mobile pour le dock */
        @media (max-width: 600px) {
            body { padding-bottom: 80px; } /* S'assurer que le bas est dégagé */
            .dock-menu {
                width: 90%;
                padding: 8px;
                gap: 8px;
                justify-content: center;
            }
            .dock-menu-item {
                width: 48px;
                height: 48px;
                font-size: 24px;
            }
        }


        /* Styles spécifiques au desktop pour le panneau d'édition rapide */
        @media (min-width: 768px) {
            body { padding: 15px; padding-bottom: 90px; } /* Espace pour le dock */
            .dynamic-list-item { flex-direction: row; }
            #quickEditModal { 
                width: 90%; 
                max-width: 700px; 
                height: auto; max-height: 90vh; 
                margin: auto; 
                border: 1px solid var(--border-color); 
                border-radius: 8px; 
            }
            #quickEditPanel { 
                display: flex; 
                flex-direction: column;
                gap: 15px;
            }
            .quick-edit-content { 
                display: grid; 
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
                gap: 15px; 
            }
            #quickEditPanel .member-info-header {
                display: flex;
                flex-direction: row;
                align-items: center;
                gap: 20px;
                margin-bottom: 15px;
                padding-bottom: 10px;
                border-bottom: 1px solid var(--border-color);
            }
             #quickEditPanel .member-info-header > * { margin: 0 !important; }

            .wizard-nav { flex-wrap: nowrap; }
            .wizard-nav-btn { width: auto; margin-top: 0; }
            #annotationModal { width: 95vw; max-width: 1400px; height: 95vh; border: 1px solid var(--border-color); border-radius: 8px;}
            .annotation-wrapper { flex-direction: row; }
            .annotation-toolbar { order: 1; flex-direction: column; width: 250px; border-top: none; border-right: 1px solid var(--border-color); }
            .toolbar-main-tools, .toolbar-contextual-tools { flex-direction: column; overflow-x: hidden; }
            .tool-btn { flex-direction: row; justify-content: flex-start; min-width: unset; }
            .tool-controls.active, #contextual_tools.active { 
                 overflow-x: hidden;
                 max-width: none;
            }
            .annotation-actions { flex-direction: column; margin-top: auto; padding-top: 20px; }
            .annotation-actions button { justify-content: flex-start; }
            .annotation-canvas-container { order: 2; padding: 10px; }
            
            .quick-edit-content h5 { font-size: 0.9em; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase; }
        }
        @media (max-width: 767px) {
            #quickEditPanel .member-info-header {
                display: block; 
            }
        }
    </style>
</head>
<body class="dark-mode">

    <dialog id="presentationModal">
        <div id="presentation-content">
            </div>
        <div class="modal-actions-pdf">
            <button id="downloadPdfBtn" type="button" class="wizard-nav-btn">
                Télécharger le PDF <span class="material-symbols-outlined" style="font-size: 1.2em;">picture_as_pdf</span>
            </button>
            <button id="closePresentationModalBtn" type="button" class="wizard-nav-btn" style="background-color: var(--danger-red); color: white;">
                Fermer
            </button>
        </div>
    </dialog>
    
    <!-- Bouton de thème original supprimé car il est maintenant dans le dock -->
    <!-- <button id="darkModeToggle" title="Changer le thème"><span class="material-symbols-outlined" id="darkModeIcon">nightlight</span></button> -->

    <dialog id="quickEditModal">
        <div class="modal-form">
            <h3 id="quick_modal_title">Édition rapide</h3>
            <div id="quick_modal_content" class="modal-content"></div>
            <div class="modal-actions">
                <button type="button" id="quick_modal_closeBtn">Fermer</button>
            </div>
        </div>
    </dialog>

    <dialog id="annotationModal">
        <div class="annotation-wrapper">
            <div class="annotation-toolbar">
                 <div id="contextual_tools">
                     <div class="toolbar-contextual-tools">
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
                            <label for="rotation_input" style="font-size: 0.8em; margin:0;">Rotation (Degrés)</label>
                            <input type="number" id="rotation_input" min="0" max="360" step="1" value="0" style="max-width: 80px; text-align: center; padding: 5px; height: 35px; margin: 0;" onchange="updateAnnotationRotation()">
                        </div>
                        <button id="edit_text_btn" class="tool-btn"><span class="material-symbols-outlined">text_fields</span>Texte</button>
                         <button id="delete_btn" class="tool-btn" style="background-color: var(--danger-red); color: white;"><span class="material-symbols-outlined">delete</span>Supprimer</button>
                     </div>
                 </div>
                 <div class="toolbar-main-tools">
                     <button id="tool_move" class="tool-btn active"><span class="material-symbols-outlined">pan_tool</span>Déplacer</button>
                     <button id="tool_location" class="tool-btn"><span class="material-symbols-outlined">pin_drop</span>Emplacement</button>
                     <button id="tool_arrow" class="tool-btn"><span class="material-symbols-outlined">call_made</span>Désigner</button>
                     <button id="tool_box" class="tool-btn"><span class="material-symbols-outlined">crop_free</span>Encadrer</button>
                 </div>
                 <div id="controls_location" class="tool-controls">
                     <label for="circle_text">Texte:</label>
                     <input type="text" id="circle_text" value="Zone">
                     <label for="circle_opacity">Transparence:</label>
                     <input type="range" id="circle_opacity" min="0.1" max="1" step="0.1" value="0.5">
                 </div>
                 <div id="controls_arrow" class="tool-controls">
                     <label for="arrow_thickness">Épaisseur:</label>
                     <input type="range" id="arrow_thickness" min="1" max="25" step="1" value="5">
                 </div>
                 <div id="controls_box" class="tool-controls">
                     <label for="box_thickness">Épaisseur:</label>
                     <input type="range" id="box_thickness" min="1" max="20" step="1" value="5">
                 </div>
                 <div class="annotation-actions">
                     <button id="tool_reset" class="tool-btn"><span class="material-symbols-outlined">delete_sweep</span>Effacer tout</button>
                     <button id="annotation_cancel" class="tool-btn">Annuler</button>
                     <button id="annotation_save" class="tool-btn" style="background-color: #27ae60; color: white;"><span class="material-symbols-outlined">save</span>Sauvegarder</button>
                 </div>
            </div>
            <div class="annotation-canvas-container">
                <canvas id="annotationCanvas"></canvas>
            </div>
        </div>
    </dialog>

    <div class="container">
        <h1>Générateur d'OI</h1>
        
        <ul class="wizard-progress">
            <li class="wizard-progress-step" onclick="goToStep(0)"><span class="material-symbols-outlined" style="font-size: 1.2em; margin-right: 5px;">info</span>1. Situation</li>
            <li class="wizard-progress-step" onclick="goToStep(1)"><span class="material-symbols-outlined" style="font-size: 1.2em; margin-right: 5px;">person_search</span>2. Adversaire</li>
            <li class="wizard-progress-step" onclick="goToStep(2)"><span class="material-symbols-outlined" style="font-size: 1.2em; margin-right: 5px;">landscape</span>3. Environnement</li>
            <li class="wizard-progress-step" onclick="goToStep(3)"><span class="material-symbols-outlined" style="font-size: 1.2em; margin-right: 5px;">flag</span>4. Mission</li>
            <li class="wizard-progress-step" onclick="goToStep(4)"><span class="material-symbols-outlined" style="font-size: 1.2em; margin-right: 5px;">schedule</span>5. Exécution</li>
            <li class="wizard-progress-step" onclick="goToStep(5)"><span class="material-symbols-outlined" style="font-size: 1.2em; margin-right: 5px;">route</span>6. Articulation</li>
            <li class="wizard-progress-step" onclick="goToStep(6)"><span class="material-symbols-outlined" style="font-size: 1.2em; margin-right: 5px;">directions_car</span>7. PATRACDVR</li>
            <li class="wizard-progress-step" onclick="goToStep(7)"><span class="material-symbols-outlined" style="font-size: 1.2em; margin-right: 5px;">add_a_photo</span>8. Photos</li>
            <li class="wizard-progress-step" onclick="goToStep(8)"><span class="material-symbols-outlined" style="font-size: 1.2em; margin-right: 5px;">check_circle</span>9. Finalisation</li>
        </ul>

        <form id="oi-form">
            <div class="wizard-content">
                <div class="wizard-step">
                    <h2>1. Situation</h2>
                    <label for="date_op">Date de l'opération:</label><input type="date" id="date_op">
                    <label for="situation_generale">1.1 Générale:</label><textarea id="situation_generale"></textarea>
                    <label for="situation_particuliere">1.2 Particulière:</label><textarea id="situation_particuliere"></textarea>
                </div>

                <div class="wizard-step">
                    <h2>2. Adversaire(s)</h2>
                    
                    <!-- ADVERSAIRE PRINCIPAL (OBJECTIF 1) -->
                    <div class="collapsible-container open">
                        <div class="collapsible-header"><h3>Adversaire Principal (Objectif 1)</h3><span class="material-symbols-outlined">expand_more</span></div>
                        <div class="collapsible-content">
                            <label>Photo principale de l'adversaire (Aperçu):</label>
                            <div id="adversary_photo_display" class="photo-display-area"></div>
                            <label for="nom_adversaire">Nom/Prénom:</label><input type="text" id="nom_adversaire">
                            <label for="domicile_adversaire">Domicile:</label><textarea id="domicile_adversaire" rows="2"></textarea>
                            <label>Moyens Employés (ME):</label><div id="me_container"></div><button type="button" class="add-btn" onclick="addMeField()">➕ ME</button>
                            <h3>Informations TO</h3>
                            <h4>Date et lieu de naissance:</h4>
                            <div class="dynamic-list-item"><input type="date" id="date_naissance"><input type="text" id="lieu_naissance" placeholder="Lieu de naissance"></div>
                            <div class="dynamic-list-item"><input type="text" id="stature_adversaire" placeholder="Stature"><select id="ethnie_adversaire"><option>Caucasien</option><option>Nord africain</option><option>Afro-antillais</option><option>Asiatique</option></select></div>
                            <label for="signes_particuliers">Signes particuliers:</label><input type="text" id="signes_particuliers">
                            <label for="profession_adversaire">Profession:</label><input type="text" id="profession_adversaire">
                            <label for="antecedents_adversaire">Antécédents:</label><textarea id="antecedents_adversaire" rows="2"></textarea>
                            
                            <label>État d'esprit:</label>
                            <div id="etat_esprit_container" class="chip-container" data-options='["Serein", "Hostile", "Conciliant", "Sur ses gardes"]'></div>
                            <label for="attitude_adversaire">Attitude (connue):</label><textarea id="attitude_adversaire" rows="2"></textarea>
                            
                            <label>Volume (renfort potentiel):</label>
                            <div id="volume_adversaire_container" class="chip-container" data-options='["Seul", "Famille", "BO", "Conjointe", "2-3", "4+"]'></div>
                            
                            <h3 style="margin-top: 20px;">Photos supplémentaires de l'adversaire (Aperçu)</h3>
                            <div id="adversary_extra_photos_display" class="photo-display-area"></div>
                            <label for="substances_adversaire">Substances:</label><input type="text" id="substances_adversaire">
                            <label>Véhicules:</label><div id="vehicules_container"></div><button type="button" class="add-btn" onclick="addDynamicField('vehicules_container')">➕</button>
                            <label for="armes_connues">Armes connues:</label><input type="text" id="armes_connues">
                        </div>
                    </div>
                    
                    <!-- ADVERSAIRE SECONDAIRE (OBJECTIF 2) -->
                    <div class="collapsible-container">
                        <div class="collapsible-header"><h3>Adversaire Secondaire (Objectif 2)</h3><span class="material-symbols-outlined">expand_more</span></div>
                        <div class="collapsible-content">
                            <label>Photo principale de l'adversaire 2 (Aperçu):</label>
                            <div id="adversary_photo_display_2" class="photo-display-area"></div>
                            <label for="nom_adversaire_2">Nom/Prénom:</label><input type="text" id="nom_adversaire_2">
                            <label for="domicile_adversaire_2">Domicile:</label><textarea id="domicile_adversaire_2" rows="2"></textarea>
                            <label>Moyens Employés (ME) 2:</label><div id="me_container_2"></div><button type="button" class="add-btn" onclick="addMeField(null, 'me_container_2')">➕ ME</button>
                            <h3>Informations TO 2</h3>
                            <h4>Date et lieu de naissance 2:</h4>
                            <div class="dynamic-list-item"><input type="date" id="date_naissance_2"><input type="text" id="lieu_naissance_2" placeholder="Lieu de naissance"></div>
                            <div class="dynamic-list-item"><input type="text" id="stature_adversaire_2" placeholder="Stature"><select id="ethnie_adversaire_2"><option>Caucasien</option><option>Nord africain</option><option>Afro-antillais</option><option>Asiatique</option></select></div>
                            <label for="signes_particuliers_2">Signes particuliers 2:</label><input type="text" id="signes_particuliers_2">
                            <label for="profession_adversaire_2">Profession 2:</label><input type="text" id="profession_adversaire_2">
                            <label for="antecedents_adversaire_2">Antécédents 2:</label><textarea id="antecedents_adversaire_2" rows="2"></textarea>
                            
                            <label>État d'esprit 2:</label>
                            <div id="etat_esprit_container_2" class="chip-container" data-options='["Serein", "Hostile", "Conciliant", "Sur ses gardes"]'></div>
                            <label for="attitude_adversaire_2">Attitude (connue) 2:</label><textarea id="attitude_adversaire_2" rows="2"></textarea>
                            
                            <label>Volume (renfort potentiel) 2:</label>
                            <div id="volume_adversaire_container_2" class="chip-container" data-options='["Seul", "Famille", "BO", "Conjointe", "2-3", "4+"]'></div>
                            
                            <h3 style="margin-top: 20px;">Photos supplémentaires de l'adversaire 2 (Aperçu)</h3>
                            <div id="adversary_extra_photos_display_2" class="photo-display-area"></div>
                            <label for="substances_adversaire_2">Substances 2:</label><input type="text" id="substances_adversaire_2">
                            <label>Véhicules 2:</label><div id="vehicules_container_2"></div><button type="button" class="add-btn" onclick="addDynamicField('vehicules_container_2')">➕</button>
                            <label for="armes_connues_2">Armes connues 2:</label><input type="text" id="armes_connues_2">
                        </div>
                    </div>
                    
					<h3>Photos des renforts potentiels (Aperçu)</h3>
                    <div id="renforts_photo_display" class="photo-display-area"></div>
                </div>
                
                <div class="wizard-step">
                    <h2>3. Environnement</h2>
                     <label>Ami(e)s (Unités en soutien):</label><input type="text" id="amies">
                     <label>Terrain / Météo:</label><input type="text" id="terrain_info">
                     <label>Population:</label><input type="text" id="population">
                     <label for="cadre_juridique">Cadre juridique:</label><input type="text" id="cadre_juridique">
                </div>

                <div class="wizard-step">
                    <h2>4. Mission du PSIG</h2>
                    <textarea id="missions_psig" rows="8">

INTERPELLER L'OBJECTIF.

ASSISTER LORS DE LA PERQUISITION.

CONDUITE AU LIEU DE GAV.</textarea>
                </div>

                <div class="wizard-step">
                     <h2>5. Exécution</h2>
                     <label for="date_execution">Date d'exécution:</label><input type="date" id="date_execution">
                     <label for="heure_execution">Heure d'exécution (H):</label><input type="time" id="heure_execution" value="06:00">
                     <!-- CHAMP DE TEXTE LIBRE POUR LA PHRASE DE MISSION -->
                     <label for="action_body_text">Corps de la mission (Exécution):</label>
                     <textarea id="action_body_text" rows="4">En vue d'appréhender le(s) mis en cause et empêcher la déperdition des preuves,
Je veux, le (date) à partir de (heure), pour une action (type d'action) investir le domicile
présumé de (Nom Adversaire 1) et (Nom Adversaire 2) après avoir bouclé celui-ci.</textarea>
                     <!-- Fin de la modification -->
                     <h3>Chronologie</h3><div id="time_events_container"></div><button type="button" class="add-btn" onclick="addTimeEvent()">➕</button>
                     <h3>Hypothèses</h3>
                     <label for="hypothese_h1">H1:</label><input type="text" id="hypothese_h1" value="Target présente LE1">
                     <label for="hypothese_h2">H2:</label><input type="text" id="hypothese_h2" value="Target présente LE2">
                     <label for="hypothese_h3">H3:</label><input type="text" id="hypothese_h3" value="Target absente LE 1 et 2">
                </div>

                <div class="wizard-step">
                     <h2>6. Articulation (MOIPC/ZMSPCP)</h2>
                     <label for="place_chef">Place du Chef (Générale):</label><input type="text" id="place_chef">
                     <div class="collapsible-container">
                          <div class="collapsible-header"><h3>Équipe INDIA (INTER)</h3><span class="material-symbols-outlined">expand_more</span></div>
                          <div class="collapsible-content">
                                 <label for="india_mission">Mission:</label><textarea id="india_mission" rows="3">RECONNAÎTRE LE DOMICILE EN VUE D'APPRÉHENDER L'OBJECTIF</textarea>
                                 
                                 <h3>Composition</h3>
                                 <div id="india_composition_display" class="articulation-composition-display">
                                     <p><i>La composition sera affichée ici après configuration dans l'onglet PATRACDVR.</i></p>
                                 </div>

                                 <label for="india_objectif">Objectif:</label><input type="text" id="india_objectif">
                                 <label for="india_itineraire">Itinéraire:</label><textarea id="india_itineraire" rows="3"></textarea>
                                 
                                 <h3>Photos - Itinéraire (Aperçu)</h3>
                                 <h4>Itinéraire Extérieur</h4>
                                 <div id="photo_container_itineraire_exterieur_display" class="photo-display-area"></div>
                                 <h4>Itinéraire Intérieur</h4>
                                 <div id="photo_container_itineraire_interieur_display" class="photo-display-area"></div>

                                 <label for="india_points_particuliers">Points Particuliers:</label><textarea id="india_points_particuliers" rows="3"></textarea>
                                 <label for="india_cat">Conduite à Tenir:</label><textarea id="india_cat" rows="6">- Si décelé, dynamiser jusqu'au domicile.
- Si présence tierce personne lors de la progression, contrôler.
- Si fuite, CR direction fuite + interpellation.
- Si rébellion, usage du strict niveau de force nécessaire.
- Si retranchement, CR + réarticulation pour fixer l'adversaire.</textarea>
                          </div>
                     </div>
                     <div class="collapsible-container">
                          <div class="collapsible-header"><h3>Équipe Appui/Observation (AO) - ZMSPCP</h3><span class="material-symbols-outlined">expand_more</span></div>
                          <div class="collapsible-content">
                             
                                 <h3>Composition</h3>
                                 <div id="ao_composition_display" class="articulation-composition-display">
                                     <p><i>La composition sera affichée ici après configuration dans l'onglet PATRACDVR.</i></p>
                                 </div>

                                 <label for="ao_zone_installation">Zone d'installation (Z):</label><textarea id="ao_zone_installation" rows="3"></textarea>
                                 <h3>Photos - Zone d'installation (Aperçu)</h3>
                                 <h4>Baptême terrain</h4>
                                 <div id="photo_container_bapteme_terrain_display" class="photo-display-area"></div>
                                 <h4>Emplacement AO</h4>
                                 <div id="photo_container_emplacement_ao_display" class="photo-display-area"></div>

                                 <label for="ao_mission">Mission (M):</label><textarea id="ao_mission" rows="3">BOUCLER - SURVEILLER - INTERDIRE TOUTE FUITE</textarea>
                                 <label for="ao_secteur_surveillance">Secteur de surveillance (S):</label><textarea id="ao_secteur_surveillance" rows="3"></textarea>
                                 <label for="ao_points_particuliers">Points Particuliers (P):</label><textarea id="ao_points_particuliers" rows="3"></textarea>
                                 <label for="ao_cat">Conduite à Tenir (C):</label><textarea id="ao_cat" rows="6">- Compte rendu de mise en place.
- Renseigner régulièrement.
- Si décelé, CR.
- Si fuite, CR direction fuite + interpellation si rapport de force favorable.
- Si rébellion, usage du strict minimum de force nécessaire.
- Si retranchement, CR + réarticulation pour fixer l'adversaire.</textarea>
                                 <label for="ao_place_chef">Place du Chef (P):</label><input type="text" id="ao_place_chef">
                          </div>
                     </div>
                </div>
                
                <div class="wizard-step">
                    <h2>7. PATRACDVR</h2>
                    <div style="margin-bottom: 20px; padding: 15px; border: 1px solid var(--border-color); border-radius: 5px;">
                        
                        <div style="display: flex; flex-wrap: wrap; justify-content: space-between; gap: 10px;">
                            <!-- CONSERVATION DU BOUTON DE RÉINITIALISATION DE LA CONFIG LOCALE -->
                            <button type="button" id="resetPatracdvrBtn" class="remove-btn" title="Réinitialiser PATRACDVR" style="flex-grow: 1; max-width: 150px;">
                                <span class="material-symbols-outlined">delete_forever</span> Réinitialiser
                            </button>
                        </div>
                    </div>

                    <div id="quickEditPanel" style="display:none;">
                        <div class="member-info-header">
                            <h4 style="margin: 0;">Membre: <span id="selectedMemberTrigramme" style="font-size: 1.1em; font-weight: bold;">Aucun</span></h4>
                            <div style="flex-grow: 1;">
                                <label for="quick_edit_trigramme_input" style="font-size: 0.8em; margin-bottom: 2px;">Modifier Trigramme:</label>
                                <input type="text" id="quick_edit_trigramme_input" placeholder="Nouveau trigramme" style="padding: 8px; margin-bottom: 0; min-height: 38px; font-size: 1em;">
                            </div>
                        </div>
                        
                        <div class="quick-edit-content"></div>
                         <div class="quick-edit-buttons">
                              <button type="button" id="saveQuickEditBtn" class="add-btn">Sauvegarder les changements</button>
                         </div>
                    </div>

                    <h4 style="margin-top: 20px;">Ajouter un véhicule ou un membre</h4>
                   <div id="vehicle_creation_buttons" style=" display: flex; flex-wrap: wrap; justify-content: space-between; gap: 10px;">
                        <button type="button" class="add-btn add-vehicle-btn" id="addManualVehicleBtn">➕ Véhicule Manuel</button>
                        <button type="button" class="add-btn add-vehicle-btn" id="addManualMemberBtn">➕ Membre Manuel</button>
                        </div>

                    <h4 style="margin-top: 20px;">Composition des véhicules</h4>
                    <div id="patracdvr_container"></div>
                    
                    <h4 style="margin-top: 20px;">Personnel à attribuer</h4>
                    <div id="unassigned_members_container"></div>
                    
                    <div id="trashCan" class="mt-4">
                        <span class="material-symbols-outlined">auto_delete</span>
                        JETER ICI pour supprimer définitivement le membre.
                    </div>
                </div>

                <div class="wizard-step">
                    <h2>8. Gestion des Photos</h2>
                    <p>Utilisez cette section pour ajouter et annoter toutes les photos.</p>
                
                    <!-- ADVERSAIRE PRINCIPAL -->
                    <div class="collapsible-container">
                        <div class="collapsible-header">
                            <h3>Adversaire Principal (Objectif 1)</h3>
                            <span class="material-symbols-outlined">expand_more</span>
                        </div>
                        <div class="collapsible-content" style="display: flex; flex-direction: column; gap: 15px;">
                            <div class="photo-upload-section">
                                <h4>Photo Principale</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('adversary_photo_input').click()">➕ Ajouter / Remplacer Photo</button>
                                <input type="file" id="adversary_photo_input" class="photo-input" accept="image/jpeg, image/png" onchange="handleFileChange(this, 'adversary_photo_preview_container', true)">
                                <div id="adversary_photo_preview_container" class="image-preview-container"></div>
                            </div>
                            <div class="photo-upload-section">
                                <h4>Photos Supplémentaires</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('adversary_extra_photos_input').click()">➕ Ajouter Photo(s)</button>
                                <input type="file" id="adversary_extra_photos_input" class="photo-input" accept="image/jpeg, image/png" multiple onchange="handleFileChange(this, 'adversary_extra_photos_preview_container', false)">
                                <div id="adversary_extra_photos_preview_container" class="image-preview-container"></div>
                            </div>
                            <div class="photo-upload-section">
                                <h4>Photos Renforts Potentiels</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('renforts_photo_input').click()">➕ Ajouter Photo(s)</button>
                                <input type="file" id="renforts_photo_input" class="photo-input" accept="image/jpeg, image/png" multiple onchange="handleFileChange(this, 'renforts_photo_preview_container', false)">
                                <div id="renforts_photo_preview_container" class="image-preview-container"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- ADVERSAIRE SECONDAIRE -->
                    <div class="collapsible-container">
                        <div class="collapsible-header">
                            <h3>Adversaire Secondaire (Objectif 2)</h3>
                            <span class="material-symbols-outlined">expand_more</span>
                        </div>
                        <div class="collapsible-content" style="display: flex; flex-direction: column; gap: 15px;">
                            <div class="photo-upload-section">
                                <h4>Photo Principale 2</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('adversary_photo_input_2').click()">➕ Ajouter / Remplacer Photo</button>
                                <input type="file" id="adversary_photo_input_2" class="photo-input" accept="image/jpeg, image/png" onchange="handleFileChange(this, 'adversary_photo_preview_container_2', true)">
                                <div id="adversary_photo_preview_container_2" class="image-preview-container"></div>
                            </div>
                            <div class="photo-upload-section">
                                <h4>Photos Supplémentaires 2</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('adversary_extra_photos_input_2').click()">➕ Ajouter Photo(s)</button>
                                <input type="file" id="adversary_extra_photos_input_2" class="photo-input" accept="image/jpeg, image/png" multiple onchange="handleFileChange(this, 'adversary_extra_photos_preview_container_2', false)">
                                <div id="adversary_extra_photos_preview_container_2" class="image-preview-container"></div>
                            </div>
                        </div>
                    </div>
                
                    <div class="collapsible-container">
                        <div class="collapsible-header">
                            <h3>Articulation</h3>
                            <span class="material-symbols-outlined">expand_more</span>
                        </div>
                        <div class="collapsible-content" style="display: flex; flex-direction: column; gap: 15px;">
                             <div class="photo-upload-section">
                                <h4>Itinéraire Extérieur (INDIA)</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('photo_container_itineraire_exterieur_input').click()">➕ Ajouter Photo(s)</button>
                                <input type="file" id="photo_container_itineraire_exterieur_input" class="photo-input" accept="image/jpeg, image/png" multiple onchange="handleFileChange(this, 'photo_container_itineraire_exterieur_preview_container', false)">
                                <!-- CORRECTION: Changer le conteneur d'upload ici -->
                                <div id="photo_container_itineraire_exterieur_preview_container" class="image-preview-container"></div>
                            </div>
                             <div class="photo-upload-section">
                                <h4>Itinéraire Intérieur (INDIA)</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('photo_container_itineraire_interieur_input').click()">➕ Ajouter Photo(s)</button>
                                <input type="file" id="photo_container_itineraire_interieur_input" class="photo-input" accept="image/jpeg, image/png" multiple onchange="handleFileChange(this, 'photo_container_itineraire_interieur_preview_container', false)">
                                <!-- CORRECTION: Changer le conteneur d'upload ici -->
                                <div id="photo_container_itineraire_interieur_preview_container" class="image-preview-container"></div>
                            </div>
                             <div class="photo-upload-section">
                                <h4>Baptême Terrain (AO)</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('photo_container_bapteme_terrain_input').click()">➕ Ajouter Photo(s)</button>
                                <input type="file" id="photo_container_bapteme_terrain_input" class="photo-input" accept="image/jpeg, image/png" multiple onchange="handleFileChange(this, 'photo_container_bapteme_terrain_preview_container', false)">
                                <!-- CORRECTION: Changer le conteneur d'upload ici -->
                                <div id="photo_container_bapteme_terrain_preview_container" class="image-preview-container"></div>
                            </div>
                            <div class="photo-upload-section">
                                <h4>Emplacement (AO)</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('photo_container_emplacement_ao_input').click()">➕ Ajouter Photo(s)</button>
                                <input type="file" id="photo_container_emplacement_ao_input" class="photo-input" accept="image/jpeg, image/png" multiple onchange="handleFileChange(this, 'photo_container_emplacement_ao_preview_container', false)">
                                <!-- CORRECTION: Changer le conteneur d'upload ici -->
                                <div id="photo_container_emplacement_ao_preview_container" class="image-preview-container"></div>
                            </div>
                        </div>
                    </div>
                
                    <div class="collapsible-container">
                        <div class="collapsible-header">
                            <h3>Logistique & Divers</h3>
                            <span class="material-symbols-outlined">expand_more</span>
                        </div>
                        <div class="collapsible-content" style="display: flex; flex-direction: column; gap: 15px;">
                           <div class="photo-upload-section">
                                <h4>Transport PSIG vers PR</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('photo_container_transport_pr_input').click()">➕ Ajouter Photo(s)</button>
                                <input type="file" id="photo_container_transport_pr_input" class="photo-input" accept="image/jpeg, image/png" multiple onchange="handleFileChange(this, 'photo_container_transport_pr_preview_container', false)">
                                <div id="photo_container_transport_pr_preview_container" class="image-preview-container"></div>
                            </div>
                           <div class="photo-upload-section">
                                <h4>Transport PR vers Domicile/LE</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('photo_container_transport_domicile_input').click()">➕ Ajouter Photo(s)</button>
                                <input type="file" id="photo_container_transport_domicile_input" class="photo-input" accept="image/jpeg, image/png" multiple onchange="handleFileChange(this, 'photo_container_transport_domicile_preview_container', false)">
                                <div id="photo_container_transport_domicile_preview_container" class="image-preview-container"></div>
                            </div>
                             <div class="photo-upload-section">
                                <h4>Cellule Effraction</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('photo_container_cellule_effraction_input').click()">➕ Ajouter Photo(s)</button>
                                <input type="file" id="photo_container_cellule_effraction_input" class="photo-input" accept="image/jpeg, image/png" multiple onchange="handleFileChange(this, 'photo_container_cellule_effraction_preview_container', false)">
                                <div id="photo_container_cellule_effraction_preview_container" class="image-preview-container"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="wizard-step">
                    <h2>9. Finalisation & Conduites à tenir</h2>
                    
                    <h3>Conduites à tenir (CAT) Générales</h3>
                    <textarea id="cat_generales" rows="6">- Si rébellion, user du strict niveau de force nécessaire
- Si retranché, alerter en mesure de se ré-articuler
- Si tente de fuir, alerter en mesure de jalonner/interpeller
- UDA : Article L435-1 du CSI + légitime défense</textarea>
                    
                    <h3>NO GO</h3>
                    <textarea id="no_go" rows="3" placeholder="Saisir les conditions de désengagement..."></textarea>
                    <h3>Liaison</h3>
                    <textarea id="cat_liaison" rows="4">TOM: 
DIR: 
Gestuelle et visuelle entre les éléments INDIA</textarea>

                    <p style="text-align:center; margin-top: 20px;">Vérifiez les points de cohérence avant de générer l'Ordre Initial.</p>
                    
                    <div style="border: 1px solid var(--border-color); padding: 15px; border-radius: 5px; margin-top: 20px;">
                        <h3>Vérification des Données Critiques</h3>
                        <div id="coherence_alerts_container">
                             <div class="coherence-alert" style="color:var(--text-secondary); background-color:var(--bg-interactive);"><span class="material-symbols-outlined">info</span> Cliquez sur "Aperçu" pour lancer la vérification de cohérence.</div>
                        </div>
                        <div id="recap_finalisation" style="margin-top: 15px;">
                            </div>
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
                        <button class="wizard-nav-btn" id="previewBtn" type="button">Aperçu (Mode Présentation) <span class="material-symbols-outlined" style="font-size: 1.2em;">visibility</span></button>
                    </div>
                </div>
            </div>
        </form>

        <div class="wizard-nav">
            <button class="wizard-nav-btn" id="prevBtn" type="button">Précédent</button>
            <button class="wizard-nav-btn" id="nextBtn" type="button">Suivant</button>
        </div>
		<footer id="main-footer">
    © G/ Maheux
</footer>
    </div>
    
    <!-- Dock Flottant (Ajout) -->
    <div class="dock-menu" id="dockMenu">
        <!-- Bouton Changement de thème -->
        <div class="dock-menu-item" id="darkModeToggle" title="Changer le thème">
            <span class="material-symbols-outlined" id="darkModeIcon">nightlight</span>
        </div>
        <!-- Bouton Plein écran -->
        <div class="dock-menu-item" id="fullscreenToggle" title="Plein écran">
            <span class="material-symbols-outlined" id="fullscreenIcon">fullscreen</span>
        </div>
    </div>


    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@4.0.10/marked.min.js"></script>
	<script>
  if (typeof navigator.serviceWorker !== 'undefined') {
    navigator.serviceWorker.register('sw.js')
  }
</script>
    <script>
        // Configuration des membres par défaut (pour initialisation si localStorage vide)
        let memberConfig = {
            fonctions: ["Chef inter", "Chef dispo", "Chef Oscar", "DE", "Cyno", "Inter", "AO", "Sans"],
            // CORRECTION: Ajout de 'AO8' dans la liste des cellules si c'était votre modification manuelle.
            cellules: ["AO1", "AO2", "AO3", "AO4", "AO5", "AO6", "AO7", "AO8", "India 1", "India 2", "India 3", "India 4", "India 5", "Effrac", "Sans"], 
            principales: ["UMP9", "G36", "FAP", "Sans"],
            afis: ["PIE", "LBD40", "LBD44", "Sans"],
            secondaires: ["PSA"],
            grenades: ["GENL", "MP7", "Sans"],
            equipements: ["Sans", "BBAL", "Belier","Lacry", "IL", "Lot 5.11"],
            equipements2: ["Sans", "Échelle", "Stop stick", "Lacry", "Cale", "IL", "Pass"],
            tenues: ["UBAS", "4S", "Bleu", "Civile", "Ghillie", "Treillis"],
            gpbs: ["GPBL", "GPBPD", "Sans"]
        };
        const availableVehicles = ['Sharan', 'Kodiaq', '5008', 'Scénic', 'BT'];

        // NOUVEAU: Constantes pour les images de fond
        const BACKGROUND_IMAGE_LIGHT = "J.png"; 
        const BACKGROUND_IMAGE_DARK = "N.png"; 
        const BACKGROUND_IMAGE_ID = 'pdf_background_img_system'; // ID de référence pour le cache de compression

        let activeMemberId = null;

        let currentStep = 0;
        let visitedSteps = new Set();
        const steps = Array.from(document.querySelectorAll(".wizard-step"));
        const progressSteps = Array.from(document.querySelectorAll(".wizard-progress-step"));
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const previewBtn = document.getElementById('previewBtn');
        const patracdvrContainer = document.getElementById('patracdvr_container');
        const unassignedContainer = document.getElementById('unassigned_members_container');
        const resetPatracdvrBtn = document.getElementById('resetPatracdvrBtn');
        const presentationModal = document.getElementById('presentationModal'); 
        const downloadPdfBtn = document.getElementById('downloadPdfBtn'); 
        const coherenceAlertsContainer = document.getElementById('coherence_alerts_container');
        const recapFinalisation = document.getElementById('recap_finalisation');
        // REMOVED: pdfBackgroundInput was removed

        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        
        // --- NOUVEAU: Clés de stockage isolées ---
        const LOCAL_STORAGE_KEY = 'oiFormDataLite';
        const INDEXED_DB_NAME = 'OI_GeneratorLiteDB';

        /**
         * Gère la révocation des URLs d'objets pour éviter les fuites de mémoire.
         */
        let objectUrlsCache = {};
        function cleanupObjectUrls() {
            for (const urlId in objectUrlsCache) {
                if (objectUrlsCache[urlId]) {
                    URL.revokeObjectURL(objectUrlsCache[urlId]);
                }
            }
            objectUrlsCache = {};
        }

        /**
         * Gestionnaire IndexedDB pour le stockage des images.
         */
        const dbManager = {
            db: null,
            // Utilisation de la clé isolée
            dbName: INDEXED_DB_NAME,
            storeName: 'images',
        
            init() {
                return new Promise((resolve, reject) => {
                    if (this.db) {
                        return resolve(this.db);
                    }
                    const request = indexedDB.open(this.dbName, 1);
        
                    request.onerror = (event) => {
                        console.error("Erreur d'ouverture de la base de données IndexedDB", event);
                        reject("Erreur IndexedDB.");
                    };
        
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        resolve(this.db);
                    };
        
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(this.storeName)) {
                            db.createObjectStore(this.storeName);
                        }
                    };
                });
            },
        
            putItem(key, blob) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.put(blob, key);
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            },
        
            getItem(key) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.get(key);
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            },
            
            deleteItem(key) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.delete(key);
                    request.onsuccess = () => {
                         // Révocation de l'URL si elle existe dans le cache avant suppression
                         if (objectUrlsCache[key]) {
                            URL.revokeObjectURL(objectUrlsCache[key]);
                            delete objectUrlsCache[key];
                         }
                         resolve();
                    };
                    request.onerror = (event) => reject(event.target.error);
                });
            },
            
            clearAllImages() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.clear();
                    request.onsuccess = () => {
                        cleanupObjectUrls(); 
                        resolve();
                    };
                    request.onerror = (event) => reject(event.target.error);
                });
            }
        };


        const displayMap = {
            'adversary_photo_preview_container': 'adversary_photo_display',
            'adversary_extra_photos_preview_container': 'adversary_extra_photos_display',
            'renforts_photo_preview_container': 'renforts_photo_display',
            'adversary_photo_preview_container_2': 'adversary_photo_display_2',
            'adversary_extra_photos_preview_container_2': 'adversary_extra_photos_display_2',
            // CORRECTION: Remplacer les conteneurs d'affichage par les conteneurs d'upload
            'photo_container_itineraire_exterieur_preview_container': 'photo_container_itineraire_exterieur_display',
            'photo_container_itineraire_interieur_preview_container': 'photo_container_itineraire_interieur_display',
            'photo_container_bapteme_terrain_preview_container': 'photo_container_bapteme_terrain_display',
            'photo_container_emplacement_ao_preview_container': 'photo_container_emplacement_ao_display',
            'photo_container_transport_pr_preview_container': null,
            'photo_container_transport_domicile_preview_container': null,
            'photo_container_cellule_effraction_preview_container': null,
        };

        function showStep(n) {
            steps.forEach((step, index) => step.classList.toggle('active', index === n));
            progressSteps.forEach((pStep, index) => {
                pStep.classList.toggle('active', index === n);
                if(visitedSteps.has(index) && index !== n) pStep.classList.add('completed');
                else pStep.classList.remove('completed');
            });
            prevBtn.style.display = n === 0 ? "none" : "inline-block";
            // Mise à jour: 9 étapes au total (0 à 8). La dernière étape est l'index 8.
            const isLastStep = n === (steps.length - 1); 
            nextBtn.style.display = isLastStep ? "none" : "inline-block";
            
            if (isLastStep) {
                previewBtn.style.display = "inline-block";
                checkCoherence(); 
            } else {
                previewBtn.style.display = "none";
            }
        }
        function goToStep(n) {
            if (n >= 0 && n < steps.length) {
                visitedSteps.add(currentStep);
                currentStep = n;
                showStep(n);
            }
        }
        function changeStep(n) { goToStep(currentStep + n); }
        prevBtn.addEventListener('click', () => changeStep(-1));
        nextBtn.addEventListener('click', () => changeStep(1));
        
        async function handleFileChange(input, previewContainerId, isSingle) {
            const previewContainer = document.getElementById(previewContainerId);
            
            if (isSingle) {
                const existingImages = previewContainer.querySelectorAll('.image-preview');
                for (const img of existingImages) {
                    // Supprimer l'image, en passant l'élément parent pour suppression
                    await removeImage(img.id, img.closest('.image-preview-item')); 
                }
                previewContainer.innerHTML = '';
            }
        
            if (input.files.length > 0) {
                for (const file of Array.from(input.files)) {
                    const previewImgId = `img_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
        
                    let objectURL = null;
                    try {
                        await dbManager.putItem(previewImgId, file);
                        objectURL = URL.createObjectURL(file);
                        objectUrlsCache[previewImgId] = objectURL;

                        const interactiveItem = document.createElement('div');
                        interactiveItem.className = 'image-preview-item';
                        interactiveItem.innerHTML = `
                            <img id="${previewImgId}" class="image-preview" src="${objectURL}" style="display:block;" data-annotations="[]">
                            <div style="display: flex; gap: 5px; margin-top: 5px;">
                                <button type="button" class="add-btn" style="background-color: var(--accent-blue); padding: 4px 8px;" onclick="openAnnotationModal('${previewImgId}')"><span class="material-symbols-outlined" style="font-size: 1.2em;">edit</span></button>
                                <button type="button" class="remove-btn" style="padding: 4px 8px;" onclick="removeImage('${previewImgId}', this.closest('.image-preview-item'))">&times;</button>
                            </div>`;
                        previewContainer.appendChild(interactiveItem);
        
                    } catch (error) {
                        console.error("Erreur lors du stockage de l'image:", error);
                        // Révocation de l'URL si elle a été créée avant l'erreur de stockage
                        if (objectURL && objectUrlsCache[previewImgId]) {
                             URL.revokeObjectURL(objectURL);
                             delete objectUrlsCache[previewImgId];
                        }
                        alert("Une erreur est survenue lors de l'ajout de l'image.");
                    }
                }
            }
            syncAllThumbnails();
            input.value = '';
            saveFormData();
        }
        
        async function removeImage(imgId, itemElement) {
            try {
                // Révocation de l'URL de l'objet et suppression du cache
                if (objectUrlsCache[imgId]) {
                    URL.revokeObjectURL(objectUrlsCache[imgId]);
                    delete objectUrlsCache[imgId];
                }

                await dbManager.deleteItem(imgId);
                if (itemElement) itemElement.remove();
                syncAllThumbnails();
                saveFormData();
            } catch (error) {
                console.error("Erreur lors de la suppression de l'image:", error);
                // On n'alerte pas ici, car l'erreur pourrait être liée à IndexedDB,
                // mais on retire quand même l'élément de l'UI si possible.
                if (itemElement) itemElement.remove();
                syncAllThumbnails();
                saveFormData();
            }
        }
        
        function syncAllThumbnails() {
            // Nettoyer tous les conteneurs d'affichage
            document.querySelectorAll('.photo-display-area').forEach(container => {
                container.innerHTML = '';
            });
        
            for (const previewId in displayMap) {
                const displayId = displayMap[previewId];
                if (!displayId) continue;
        
                const previewContainer = document.getElementById(previewId);
                const displayContainer = document.getElementById(displayId);
        
                if (previewContainer && displayContainer) {
                    previewContainer.querySelectorAll('.image-preview-item img').forEach(previewImg => {
                        const displayImg = document.createElement('img');
                        displayImg.className = 'image-preview';
                        // IMPORTANT: Utilisez toujours l'URL de l'objet du DOM, qui est l'URL de l'objet Blob
                        displayImg.src = previewImg.src; 
                        displayImg.dataset.refId = previewImg.id;
                        displayContainer.appendChild(displayImg);
                    });
                }
            }
        }


        function addDynamicField(containerId, value = '') {
            const container = document.getElementById(containerId);
            const item = document.createElement('div');
            item.className = 'dynamic-list-item';
            item.innerHTML = `<input type="text" class="dynamic-input" value="${value}" oninput="saveFormData()"><button type="button" class="remove-btn" onclick="this.parentElement.remove(); saveFormData();">❌</button>`;
            container.appendChild(item);
        }

        function initChipContainer(containerId, selectedValues = []) {
             const container = document.getElementById(containerId);
             const options = JSON.parse(container.dataset.options || '[]');
             container.innerHTML = ''; 

             options.forEach(option => {
                 const btn = document.createElement('button');
                 btn.type = 'button';
                 btn.className = 'chip-btn';
                 btn.textContent = option;
                 if (selectedValues.includes(option)) {
                     btn.classList.add('selected');
                 }
                 btn.addEventListener('click', function() {
                     this.classList.toggle('selected');
                     saveFormData();
                 });
                 container.appendChild(btn);
             });

             const customInput = document.createElement('input');
             customInput.type = 'text';
             customInput.placeholder = 'Ajouter personnalisé (entrée)';
             customInput.onkeydown = function(event) {
                 if (event.key === 'Enter' && this.value.trim()) {
                     event.preventDefault(); 
                     const customValue = this.value.trim();
                     // Récupérer les options de base pour s'assurer de ne pas dupliquer
                     const currentOptions = JSON.parse(container.dataset.options || '[]');
                     // Récupérer les valeurs déjà sélectionnées/ajoutées dynamiquement
                     const currentSelected = getChipData(containerId);

                     if (!currentOptions.includes(customValue) && !currentSelected.includes(customValue)) {
                         const newBtn = document.createElement('button');
                         newBtn.type = 'button';
                         newBtn.className = 'chip-btn selected';
                         newBtn.textContent = customValue;
                         newBtn.addEventListener('click', btn.onclick); // Utiliser le même gestionnaire de clic
                         
                         // Insérer avant le champ de saisie pour respecter l'ordre
                         container.insertBefore(newBtn, this);
                     } else if (currentOptions.includes(customValue) && !currentSelected.includes(customValue)) {
                          // Si l'option existe mais n'est pas sélectionnée, la sélectionner
                          const existingBtn = Array.from(container.querySelectorAll('.chip-btn')).find(b => b.textContent === customValue);
                          if(existingBtn) { existingBtn.classList.add('selected'); }
                     }
                     
                     this.value = '';
                     saveFormData();
                 }
             };
             customInput.style.flexBasis = '150px';
             customInput.style.flexGrow = '0';
             customInput.style.minHeight = '40px';
             customInput.style.padding = '8px 12px';
             container.appendChild(customInput);
         }

         function getChipData(containerId) {
             const container = document.getElementById(containerId);
             const selectedChips = container.querySelectorAll('.chip-btn.selected');
             return Array.from(selectedChips).map(btn => btn.textContent);
         }

        function addMeField(value = '', containerId = 'me_container') {
            const container = document.getElementById(containerId);
            // Limiter à 3 éléments comme dans le code original
            if (container.querySelectorAll('.dynamic-list-item').length >= 3) return;
            const item = document.createElement('div');
            item.className = 'dynamic-list-item';
            const meIndex = container.querySelectorAll('.dynamic-list-item').length + 1;
            item.innerHTML = `<label>ME${meIndex}:</label><input type="text" class="me-input" value="${value}" oninput="saveFormData()"><button type="button" class="remove-btn" onclick="this.parentElement.remove(); saveFormData();">❌</button>`;
            container.appendChild(item);
        }
        
        function addTimeEvent(type_from_load, hour_from_load = '', desc_from_load) {
            const container = document.getElementById('time_events_container');
            const isLoadingFromFile = type_from_load !== undefined;

            let type, hour = hour_from_load, desc;

            if (isLoadingFromFile) {
                type = type_from_load;
                desc = desc_from_load;
            } else {
                const currentEventCount = container.children.length;
                const prefilledData = [
                    { type: 'T0', desc: 'Rasso PSIG' }, { type: 'T1', desc: 'Départ PR' },
                    { type: 'T2', desc: 'Départ LE' }, { type: 'T3', desc: 'MEP TERMINÉ' },
                    { type: 'T4', desc: 'TOP ACTION' },
                ];
                const defaultValues = prefilledData[currentEventCount] || { type: `T${currentEventCount}`, desc: ''};
                type = defaultValues.type;
                desc = defaultValues.desc;
            }

            const item = document.createElement('div');
            item.className = 'dynamic-list-item time-item draggable';
            item.id = `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            item.setAttribute('draggable', 'true');
            const optionsHtml = ['T0','T1','T2','T3','T4','T5'].map(t => 
                `<option value="${t}" ${t === type ? 'selected' : ''}>${t}</option>`
            ).join('');
            item.innerHTML = `<select class="time-type-select" onchange="saveFormData()">${optionsHtml}</select><input type="time" class="time-hour-input" value="${hour}" onchange="saveFormData()"><input type="text" class="time-description-input" placeholder="Description" value="${desc || ''}" oninput="saveFormData()"><button type="button" class="remove-btn" onclick="this.parentElement.remove(); saveFormData();">❌</button>`;
            container.appendChild(item);
        }

        function addPatracdvrRow(vehicleName, members = []) {
            const container = document.getElementById('patracdvr_container');
            if (container.querySelector(`[data-vehicle-name="${vehicleName}"]`)) {
                alert(`Le véhicule "${vehicleName}" existe déjà. Veuillez choisir un nom unique.`);
                return;
            }
            const row = document.createElement('div');
            row.className = 'patracdvr-vehicle-row';
            row.dataset.vehicleName = vehicleName;

            row.innerHTML = `
                <div class="vehicle-header">
                    <span class="vehicle-name">${vehicleName}</span>
                    <button type="button" class="remove-btn" title="Supprimer le véhicule">❌</button>
                </div>
                <div class="patracdvr-members-container"></div>`;
            
            container.appendChild(row);

            const membersContainer = row.querySelector('.patracdvr-members-container');
            row.querySelector('.remove-btn').addEventListener('click', () => {
                // Utilisation d'un `confirm` natif
                const confirmation = confirm(`Voulez-vous vraiment supprimer le véhicule "${vehicleName}" et désattribuer ses membres ?`);
                if (confirmation) {
                    // Désattribution des membres
                    membersContainer.querySelectorAll('.patracdvr-member-btn').forEach(memberBtn => {
                        memberBtn.dataset.cellule = 'Sans';
                        memberBtn.dataset.fonction = 'Sans';
                        updateMemberButtonVisuals(memberBtn);
                        unassignedContainer.appendChild(memberBtn);
                    });
                    // Suppression de la ligne du véhicule
                    row.remove();
                    // Réinitialisation du panneau d'édition rapide si le membre actif était dans ce véhicule
                    if (activeMemberId) {
                        const activeMember = document.getElementById(activeMemberId);
                        if (!document.contains(activeMember)) {
                             activeMemberId = null;
                             document.getElementById('quickEditPanel').style.display = 'none';
                        }
                    }
                    saveFormData();
                }
            });
            
            // Attacher les écouteurs de Drop uniquement au conteneur de membres du véhicule
            membersContainer.addEventListener('dragenter', handleDragEnter);
            membersContainer.addEventListener('dragleave', handleDragLeave);
            membersContainer.addEventListener('dragover', handleDragOver);
            membersContainer.addEventListener('drop', handleDrop);

            members.forEach(memberData => addPatracdvrMember(membersContainer, memberData));
            saveFormData();
        }
        
        function addManualVehicle() {
            let vehicleName = prompt("Veuillez saisir le nom du nouveau véhicule (ex: VW-Golf, VTC):");
            if (vehicleName) {
                vehicleName = vehicleName.trim();
                if (vehicleName.length > 0) {
                    addPatracdvrRow(vehicleName);
                }
            }
        }
        
        function addManualMember() {
            let trigramme = prompt("Veuillez saisir le trigramme du nouveau membre (ex: ABC):");
            if (trigramme) {
                trigramme = trigramme.trim().toUpperCase();
                const existingMember = document.querySelector(`.patracdvr-member-btn[data-trigramme="${trigramme}"]`);
                if (existingMember) {
                    alert(`Le membre avec le trigramme "${trigramme}" existe déjà. Veuillez en choisir un autre.`);
                    return;
                }
                
                if (trigramme.length >= 2 && trigramme.length <= 4) {
                    const initialData = { 
                        trigramme: trigramme, 
                        cellule: 'Sans', 
                        fonction: 'Sans',
                        principales: 'Sans', 
                        secondaires: 'PSA', 
                        afis: 'Sans',       
                        grenades: 'Sans',   
                        equipement: 'Sans',
                        equipement2: 'Sans',
                        tenues: 'UBAS',
                        gpb: 'GPBL'
                    };
                    addPatracdvrMember(unassignedContainer, initialData);
                    
                    const newMemberBtn = unassignedContainer.lastChild;
                    if (newMemberBtn) {
                        handleMemberSelection({ target: newMemberBtn });
                    }
                    saveFormData();
                } else {
                    alert("Le trigramme doit contenir entre 2 et 4 caractères.");
                }
            }
        }
        
        function addPatracdvrMember(containerElement, data = {}) {
            if (!containerElement) return;
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'patracdvr-member-btn draggable';
            btn.id = `member_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            btn.setAttribute('draggable', 'true');
            const memberData = {
                trigramme: 'N/A', 
                fonction: 'Sans', 
                cellule: 'India 1', 
                principales: 'Sans', 
                secondaires: 'PSA',
                afis: 'Sans',
                grenades: 'Sans',
                equipement: 'Sans', 
                equipement2: 'Sans',
                tenues: 'UBAS',
                gpb: 'GPBL', 
                ...data
            };
            Object.keys(memberData).forEach(key => btn.dataset[key] = memberData[key]);
            updateMemberButtonVisuals(btn);
            containerElement.appendChild(btn);
        }
        function updateMemberButtonVisuals(btn) {
            const trigramme = btn.dataset.trigramme || 'N/A';
            const fonction = btn.dataset.fonction || '';
            const cellule = btn.dataset.cellule || '';
            const cellDisplay = cellule !== 'Sans' ? cellule : '';
            const functionDisplay = fonction !== 'Sans' ? ` / ${fonction}` : '';
            const separation = (cellDisplay && functionDisplay) ? '' : ''; 
            
            btn.innerHTML = `<span class="trigramme">${trigramme}</span><span class="fonction">${cellDisplay}${separation}${functionDisplay}</span>`;
            
            // Si le membre est dans le conteneur "Personnel à attribuer", on masque la fonction/cellule.
            if (btn.closest('#unassigned_members_container')) {
                btn.innerHTML = `<span class="trigramme">${trigramme}</span>`;
            }
        }

        function updateArticulationDisplay() {
            const indiaContainer = document.getElementById('india_composition_display');
            const aoContainer = document.getElementById('ao_composition_display');
            
            const indiaMembersByCell = {};
            const aoMembersByCell = {};

            document.querySelectorAll('.patracdvr-member-btn').forEach(btn => {
                const trigramme = btn.dataset.trigramme;
                const cellule = btn.dataset.cellule;
                if (!trigramme || !cellule || cellule.toLowerCase() === 'sans') return;

                if (cellule.toLowerCase().startsWith('india')) {
                    if (!indiaMembersByCell[cellule]) {
                        indiaMembersByCell[cellule] = [];
                    }
                    indiaMembersByCell[cellule].push(trigramme);
                } else if (cellule.toLowerCase().startsWith('ao')) {
                    if (!aoMembersByCell[cellule]) {
                        aoMembersByCell[cellule] = [];
                    }
                    aoMembersByCell[cellule].push(trigramme);
                }
            });

            const naturalSort = (a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
            
            let indiaHtml = '';
            const sortedIndiaKeys = Object.keys(indiaMembersByCell).sort(naturalSort);
            sortedIndiaKeys.forEach(cell => {
                indiaHtml += `<p><strong>${cell}:</strong> ${indiaMembersByCell[cell].join(', ')}</p>`;
            });
            indiaContainer.innerHTML = indiaHtml || `<p><i>Aucun membre assigné aux cellules India.</i></p>`;

            let aoHtml = '';
            const sortedAoKeys = Object.keys(aoMembersByCell).sort(naturalSort);
            sortedAoKeys.forEach(cell => {
                aoHtml += `<p><strong>${cell}:</strong> ${aoMembersByCell[cell].join(', ')}</p>`;
            });
            aoContainer.innerHTML = aoHtml || `<p><i>Aucun membre assigné aux cellules AO.</i></p>`;
        }

        const quickEditMapping = {
            'Cellule': { key: 'cellules', attribute: 'cellule' },
            'Fonction': { key: 'fonctions', attribute: 'fonction' },
            'Arme P.': { key: 'principales', attribute: 'principales' },
            'Arme S.': { key: 'secondaires', attribute: 'secondaires' },
            'A.F.I.': { key: 'afis', attribute: 'afis' },
            'Grenades': { key: 'grenades', attribute: 'grenades' },
            'Équip. 1': { key: 'equipements', attribute: 'equipement' },
            'Équip. 2': { key: 'equipements2', attribute: 'equipement2' },
            'Tenue': { key: 'tenues', attribute: 'tenue' },
            'GPB': { key: 'gpbs', attribute: 'gpb' }
        };
        
        function setupQuickEditPanel() {
            const contentContainer = document.querySelector('#quickEditPanel .quick-edit-content');
            contentContainer.innerHTML = '';
            
            for (const [title, config] of Object.entries(quickEditMapping)) {
                
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'quick-edit-category';
                
                const panelTitle = document.createElement('h5');
                panelTitle.textContent = title;
                categoryDiv.appendChild(panelTitle);
                
                const optionsContainer = document.createElement('div');
                optionsContainer.className = 'quick-edit-options';
                
                (memberConfig[config.key] || []).forEach(option => {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'quick-edit-btn';
                    btn.textContent = option;
                    btn.dataset.attribute = config.attribute;
                    btn.dataset.value = option;
                    optionsContainer.appendChild(btn);
                });
                
                categoryDiv.appendChild(optionsContainer);
                contentContainer.appendChild(categoryDiv);
            }
        }
        
        function handleMemberSelection(event) {
            // Utiliser closest pour s'assurer que l'on obtient le bouton, même si l'on clique sur un span enfant
            const clickedButton = event.target.closest('.patracdvr-member-btn'); 
            if (!clickedButton) return;

            // Empêcher la propagation pour ne pas déclencher d'autres écouteurs
            event.stopPropagation();

            if (activeMemberId === clickedButton.id) {
                // Désélectionner
                clickedButton.classList.remove('member-active');
                activeMemberId = null;
                document.getElementById('quickEditPanel').style.display = 'none';
                return;
            }

            // Désélectionner l'ancien membre actif
            if (activeMemberId) {
                const oldActive = document.getElementById(activeMemberId);
                if (oldActive) oldActive.classList.remove('member-active');
            }
            
            // Sélectionner le nouveau membre actif
            activeMemberId = clickedButton.id;
            clickedButton.classList.add('member-active');
            
            // Afficher le panneau d'édition approprié (modal sur mobile, panneau sur desktop)
            if (window.innerWidth < 768) {
                openQuickEditModal(activeMemberId);
            } else {
                populateQuickEditPanel(activeMemberId);
                document.getElementById('quickEditPanel').style.display = 'flex';
            }
        }
        
        function populateQuickEditPanel(memberId) {
            const member = document.getElementById(memberId);
            if (!member) return;

            const trigrammeDisplay = member.dataset.trigramme || 'N/A';
            document.getElementById('selectedMemberTrigramme').textContent = trigrammeDisplay;
            document.getElementById('quick_edit_trigramme_input').value = trigrammeDisplay;

            document.querySelectorAll('#quickEditPanel .quick-edit-btn').forEach(btn => {
                const attribute = btn.dataset.attribute;
                const value = btn.dataset.value;
                btn.classList.toggle('selected', member.dataset[attribute] === value);
            });
        }

        function openQuickEditModal(memberId) {
            const modal = document.getElementById('quickEditModal');
            const title = document.getElementById('quick_modal_title');
            const content = document.getElementById('quick_modal_content');
            const member = document.getElementById(memberId);

            if (!member) return;

            title.textContent = `Édition Rapide: ${member.dataset.trigramme || 'N/A'}`;
            content.innerHTML = '';
            
            // --- Ajouter le champ de trigramme en haut de la modale ---
            const trigrammeDiv = document.createElement('div');
            trigrammeDiv.className = 'quick-edit-category';
            trigrammeDiv.innerHTML = `
                <h5>Trigramme</h5>
                <input type="text" id="modal_quick_edit_trigramme_input" placeholder="Nouveau trigramme" 
                       value="${member.dataset.trigramme || 'N/A'}" 
                       style="padding: 8px; margin-bottom: 0; min-height: 38px; font-size: 1em;">
            `;
            content.appendChild(trigrammeDiv);
            // Écouteur pour la mise à jour immédiate du trigramme (dans la modale uniquement)
            document.getElementById('modal_quick_edit_trigramme_input').addEventListener('input', (e) => {
                 member.dataset.trigramme = e.target.value.toUpperCase();
                 title.textContent = `Édition Rapide: ${member.dataset.trigramme || 'N/A'}`;
            });

            // --- Ajouter les options d'édition ---
            for (const [category, config] of Object.entries(quickEditMapping)) {
                 if (!memberConfig[config.key] || memberConfig[config.key].length === 0) continue;
                 
                const attributeName = config.attribute; 
                
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'quick-edit-category';
                
                const categoryTitle = document.createElement('h5');
                categoryTitle.textContent = category;
                categoryDiv.appendChild(categoryTitle);
                
                const optionsContainer = document.createElement('div');
                optionsContainer.className = 'quick-edit-options';
                
                (memberConfig[config.key] || []).forEach(option => {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'quick-edit-btn';
                    btn.textContent = option;
                    btn.dataset.attribute = attributeName;
                    btn.dataset.value = option;
                    if (member.dataset[attributeName] === option) {
                        btn.classList.add('selected');
                    }
                    // Le clic sera géré par la délégation d'événement de la modale
                    optionsContainer.appendChild(btn);
                });
                
                categoryDiv.appendChild(optionsContainer);
                content.appendChild(categoryDiv);
            }
            modal.showModal();
        }

        function saveQuickEditChanges() {
             const member = document.getElementById(activeMemberId);
             if (!member) return;
             
             // Mise à jour du trigramme (saisi dans le champ du panneau)
             const newTrigramme = document.getElementById('quick_edit_trigramme_input').value.toUpperCase();
             member.dataset.trigramme = newTrigramme;
             document.getElementById('selectedMemberTrigramme').textContent = newTrigramme;
             
             // Mise à jour des autres propriétés (boutons sélectionnés)
             document.querySelectorAll('#quickEditPanel .quick-edit-btn.selected').forEach(btn => {
                 const attribute = btn.dataset.attribute;
                 const value = btn.dataset.value;
                 member.dataset[attribute] = value;
                 
                 // Logique de cohérence de base
                 if (attribute === 'cellule' && value === 'Sans') {
                     member.dataset.fonction = 'Sans';
                 }
             });
             
             updateMemberButtonVisuals(member);
             saveFormData();
             populateQuickEditPanel(activeMemberId);
        }
        
        /**
         * Logique de suppression lors du drop sur la corbeille.
         */
        function handleDeleteDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            // Récupération de l'élément draggé
            const draggedId = e.dataTransfer.getData('text/plain');
            const draggedItem = document.getElementById(draggedId);
            
            if (draggedItem && draggedItem.classList.contains('patracdvr-member-btn')) {
                // Utilisation d'un `confirm` natif
                const confirmation = confirm(`Voulez-vous vraiment SUPPRIMER DÉFINITIVEMENT le membre ${draggedItem.dataset.trigramme || 'N/A'} de la session ?`);
                
                if (confirmation) {
                    const memberId = draggedItem.id;
                    draggedItem.remove();
                    
                    if (activeMemberId === memberId) {
                        activeMemberId = null;
                        document.getElementById('quickEditPanel').style.display = 'none';
                    }
                    saveFormData();
                }
            }
        }
        
        /**
         * Sauvegarde les métadonnées du formulaire dans localStorage.
         */
        function saveFormData() {
            try {
                const data = {};
                document.querySelectorAll('#oi-form input:not([type="file"]), #oi-form textarea, #oi-form select').forEach(field => {
                    if (field.id) data[field.id] = field.value;
                });
        
                data.dynamic_photos = {};
                document.querySelectorAll('.image-preview-container').forEach(container => {
                    if (container.id) {
                        const imagesMetadata = Array.from(container.querySelectorAll('.image-preview')).map(img => ({
                            id: img.id,
                            annotations: img.dataset.annotations || '[]' 
                        }));
                        if (imagesMetadata.length > 0) {
                            data.dynamic_photos[container.id] = imagesMetadata;
                        }
                    }
                });
                
                // Suppression de la sauvegarde de l'ID d'image de fond

                // Adversaire 1
                data.me_list = Array.from(document.querySelectorAll('#me_container .me-input')).map(i => i.value).filter(Boolean);
                data.etat_esprit_list = getChipData('etat_esprit_container');
                data.volume_list = getChipData('volume_adversaire_container');
                data.vehicules_list = Array.from(document.querySelectorAll(`#vehicules_container .dynamic-input`)).map(i => i.value).filter(Boolean);
                
                // Adversaire 2
                data.me_list_2 = Array.from(document.querySelectorAll('#me_container_2 .me-input')).map(i => i.value).filter(Boolean);
                data.etat_esprit_list_2 = getChipData('etat_esprit_container_2');
                data.volume_list_2 = getChipData('volume_adversaire_container_2');
                data.vehicules_list_2 = Array.from(document.querySelectorAll(`#vehicules_container_2 .dynamic-input`)).map(i => i.value).filter(Boolean);


                
                // Sauvegarde des données détaillées des membres PATRACDVR
                const memberDatasetsToSave = ['trigramme', 'fonction', 'cellule', 'equipement', 'equipement2', 'tenue', 'gpb', 
                                              'principales', 'secondaires', 'afis', 'grenades']; 

                data.patracdvr_unassigned = Array.from(unassignedContainer.querySelectorAll('.patracdvr-member-btn')).map(btn => {
                    const memberData = {};
                    memberDatasetsToSave.forEach(key => { memberData[key] = btn.dataset[key] || ''; });
                    return memberData;
                });
                
                data.patracdvr_rows = Array.from(document.querySelectorAll('#patracdvr_container .patracdvr-vehicle-row')).map(row => ({
                    vehicle: row.dataset.vehicleName,
                    members: Array.from(row.querySelectorAll('.patracdvr-member-btn')).map(btn => {
                         const memberData = {};
                         memberDatasetsToSave.forEach(key => { memberData[key] = btn.dataset[key] || ''; });
                         return memberData;
                    })
                }));
                
                data.time_events = Array.from(document.querySelectorAll('#time_events_container .time-item')).map(item => ({
                    type: item.querySelector('.time-type-select').value,
                    hour: item.querySelector('.time-hour-input').value,
                    description: item.querySelector('.time-description-input').value
                }));

                // Utilisation de la clé isolée
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(data));
                updateArticulationDisplay();
        
            } catch (e) { 
                console.error("Erreur de sauvegarde:", e); 
            }
        }
        
        /**
         * Charge les données du formulaire depuis localStorage et les images depuis IndexedDB.
         */
        async function loadFormData() {
            cleanupObjectUrls(); // S'assurer que les anciennes URLs sont révoquées avant de charger de nouvelles données
            // Utilisation de la clé isolée
            const dataString = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (!dataString) return false;
        
            try {
                const data = JSON.parse(dataString);
        
                // Nettoyer l'UI
                document.querySelectorAll('.image-preview-container, .photo-display-area').forEach(c => c.innerHTML = '');
        
                // Charger les métadonnées de base
                Object.keys(data).forEach(key => {
                     if (['dynamic_photos', 'patracdvr_rows', 'patracdvr_unassigned', 'time_events', 'me_list', 'etat_esprit_list', 'volume_list', 'vehicules_list', 'me_list_2', 'etat_esprit_list_2', 'volume_list_2', 'vehicules_list_2', 'pdf_background_id'].includes(key)) return; 
                     const el = document.getElementById(key);
                     if (el) el.value = data[key];
                });
                
                // Charger les photos depuis IndexedDB en utilisant les métadonnées
                if (data.dynamic_photos) {
                    for (const previewId in data.dynamic_photos) {
                        const previewContainer = document.getElementById(previewId);
                        const fileDataArray = data.dynamic_photos[previewId];
        
                        if (previewContainer && fileDataArray) {
                            for (const imgData of fileDataArray) {
                                const imageBlob = await dbManager.getItem(imgData.id);
                                if (imageBlob) {
                                    const objectURL = URL.createObjectURL(imageBlob);
                                    objectUrlsCache[imgData.id] = objectURL;
        
                                    const interactiveItem = document.createElement('div');
                                    interactiveItem.className = 'image-preview-item';
                                    interactiveItem.innerHTML = `
                                        <img id="${imgData.id}" class="image-preview" src="${objectURL}" style="display:block;" data-annotations='${imgData.annotations || '[]'}'>
                                        <div style="display: flex; gap: 5px; margin-top: 5px;">
                                            <button type="button" class="add-btn" style="background-color: var(--accent-blue); padding: 4px 8px;" onclick="openAnnotationModal('${imgData.id}')"><span class="material-symbols-outlined" style="font-size: 1.2em;">edit</span></button>
                                            <button type="button" class="remove-btn" style="padding: 4px 8px;" onclick="removeImage('${imgData.id}', this.closest('.image-preview-item'))">&times;</button>
                                        </div>`;
                                    previewContainer.appendChild(interactiveItem);
                                } else {
                                     console.warn(`Image avec ID ${imgData.id} non trouvée dans IndexedDB.`);
                                }
                            }
                        }
                    }
                }
                syncAllThumbnails();
                
                // Charger les autres champs dynamiques
                document.getElementById('me_container').innerHTML = '';
                document.getElementById('vehicules_container').innerHTML = '';
                document.getElementById('me_container_2').innerHTML = '';
                document.getElementById('vehicules_container_2').innerHTML = '';
                document.getElementById('time_events_container').innerHTML = '';
                
                (data.me_list || []).forEach(val => addMeField(val));
                initChipContainer('etat_esprit_container', data.etat_esprit_list || []);
                initChipContainer('volume_adversaire_container', data.volume_list || []);
                (data.vehicules_list || []).forEach(val => addDynamicField('vehicules_container', val));
                
                (data.me_list_2 || []).forEach(val => addMeField(val, 'me_container_2'));
                initChipContainer('etat_esprit_container_2', data.etat_esprit_list_2 || []);
                initChipContainer('volume_adversaire_container_2', data.volume_list_2 || []);
                (data.vehicules_list_2 || []).forEach(val => addDynamicField('vehicules_container_2', val));

                (data.time_events || []).forEach(ev => addTimeEvent(ev.type, ev.hour, ev.description));
                initializePatracdvr(data);
        
                updateArticulationDisplay();
                return true;
        
            } catch (e) {
                console.error("Erreur de chargement:", e);
                return false;
            }
        }
        
        function initializePatracdvr(dataFromStorage) {
            unassignedContainer.innerHTML = '';
            patracdvrContainer.innerHTML = '';
            if (dataFromStorage && (dataFromStorage.patracdvr_rows?.length > 0 || dataFromStorage.patracdvr_unassigned?.length > 0)) {
                (dataFromStorage.patracdvr_unassigned || []).forEach(member => addPatracdvrMember(unassignedContainer, member));
                (dataFromStorage.patracdvr_rows || []).forEach(row => addPatracdvrRow(row.vehicle, row.members));
            }
            // Si aucune donnée dans localStorage, on initialise le panneau d'édition rapide avec les valeurs par défaut JS
            setupQuickEditPanel(); 
        }

        // Suppression de let draggedItem = null; pour utiliser l'objet DataTransfer

        function getDragAfterElement(container, y) {
            // S'assurer de ne considérer que les éléments qui peuvent être déplacés
            const draggableElements = [...container.querySelectorAll('.draggable:not(.dragging):not(.time-item)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect(); 
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) { 
                    return { offset: offset, element: child }; 
                } 
                else { 
                    return closest; 
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function handleDragEnter(e) {
            e.preventDefault();
            const targetContainer = e.currentTarget;
            
            // Vérifier que c'est un membre PATRACDVR qui est dragué
            const draggedId = e.dataTransfer.getData('text/plain');
            const draggedItem = document.getElementById(draggedId);
            
            if (draggedItem && draggedItem.classList.contains('patracdvr-member-btn')) {
                if(targetContainer.id === 'trashCan') {
                    targetContainer.classList.add('drag-over');
                } else {
                    targetContainer.style.border = '2px dashed var(--accent-blue)';
                }
            }
        }

        function handleDragOver(e) {
            e.preventDefault(); 
            const targetContainer = e.currentTarget;
            const draggedId = e.dataTransfer.getData('text/plain');
            const draggedItem = document.getElementById(draggedId);

            if (draggedItem && draggedItem.classList.contains('patracdvr-member-btn')) {
                if(targetContainer.id !== 'trashCan') {
                    // Pour insérer le membre à l'endroit approprié dans le conteneur
                    const afterElement = getDragAfterElement(targetContainer, e.clientY);
                    
                    if (afterElement == null) { 
                        targetContainer.appendChild(draggedItem); 
                    } else { 
                        targetContainer.insertBefore(draggedItem, afterElement); 
                    }
                }
            }
        }

        function handleDragLeave(e) {
            const targetContainer = e.currentTarget;
            if(targetContainer.id === 'trashCan') {
                targetContainer.classList.remove('drag-over');
            } else {
                targetContainer.style.border = '1px dashed var(--border-color)';
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            const targetContainer = e.currentTarget;
            const draggedId = e.dataTransfer.getData('text/plain');
            const draggedItem = document.getElementById(draggedId);

            if (targetContainer.id === 'trashCan') {
                handleDeleteDrop(e);
                return;
            }
            
            targetContainer.style.border = '1px dashed var(--border-color)';

            if (draggedItem && draggedItem.classList.contains('patracdvr-member-btn')) {
                // L'ordre a déjà été géré dans handleDragOver, on s'assure juste du parentage
                targetContainer.appendChild(draggedItem);

                const isUnassignedZone = targetContainer.id === 'unassigned_members_container';
                
                if (isUnassignedZone) {
                    draggedItem.dataset.cellule = 'Sans';
                    draggedItem.dataset.fonction = 'Sans';
                } else {
                    // Si on déplace vers un véhicule, on réattribue une cellule par défaut si elle était "Sans"
                    if (draggedItem.dataset.cellule === 'Sans') {
                         draggedItem.dataset.cellule = 'India 1'; 
                    }
                }
                
                updateMemberButtonVisuals(draggedItem);
                
                // Désélectionner le membre actif si déplacé
                if (draggedItem.id === activeMemberId) {
                    draggedItem.classList.remove('member-active');
                    activeMemberId = null;
                    if (window.innerWidth >= 768) {
                        document.getElementById('quickEditPanel').style.display = 'none';
                    }
                }
                
                saveFormData();
            }
        }

        const annotationModal = document.getElementById('annotationModal');
        const canvas = document.getElementById('annotationCanvas');
        const ctx = canvas.getContext('2d');
        const baseImage = new Image();
        let annotations = [], currentTool = 'move', isDrawing = false, isDragging = false, startX, startY;
        let currentAnnotation = null, selectedAnnotation = null, dragOffsetX, dragOffsetY;
        const rotationInput = document.getElementById('rotation_input');
        let isMovingAnnotation = false;

        function setContextualTools(selection) {
            const contextualTools = document.getElementById('contextual_tools');
            if (selection) {
                contextualTools.classList.add('active');
                // Seulement l'outil location permet le texte
                contextualTools.classList.toggle('location-selected', selection.type === 'location'); 
                rotationInput.value = Math.round((selection.rotation || 0) * 180 / Math.PI) % 360;
                if (rotationInput.value < 0) rotationInput.value = 360 + parseInt(rotationInput.value);
            } else {
                contextualTools.classList.remove('active');
            }
        }
        
        function updateAnnotationRotation() {
            if (selectedAnnotation) {
                const degrees = parseFloat(rotationInput.value) || 0;
                selectedAnnotation.rotation = degrees * Math.PI / 180;
                redrawCanvas();
            }
        }

        function setActiveTool(toolId) {
            currentTool = toolId;
            document.querySelectorAll('.tool-btn.active, .tool-controls.active').forEach(el => el.classList.remove('active'));
            const toolButton = document.getElementById(`tool_${toolId}`);
            if (toolButton) toolButton.classList.add('active');
            const toolControls = document.getElementById(`controls_${toolId}`);
            if (toolControls) toolControls.classList.add('active');
            canvas.style.cursor = toolId === 'move' ? 'grab' : 'crosshair'; 
            selectedAnnotation = null;
            setContextualTools(null);
        }

        async function openAnnotationModal(previewImgId) {
            const previewImg = document.getElementById(previewImgId);
            if (!previewImg) return;
        
            const objectURL = objectUrlsCache[previewImgId];

            if (!objectURL) {
                 // Tenter de recharger le blob si l'URL a été révoquée
                 const imageBlob = await dbManager.getItem(previewImgId);
                 if (imageBlob) {
                     const newUrl = URL.createObjectURL(imageBlob);
                     objectUrlsCache[previewImgId] = newUrl;
                     previewImg.src = newUrl;
                 } else {
                     alert("Impossible de charger l'image pour l'annotation. Données non trouvées.");
                     return;
                 }
            }

            baseImage.onload = () => {
                canvas.width = baseImage.naturalWidth;
                canvas.height = baseImage.naturalHeight;
                annotations = JSON.parse(previewImg.dataset.annotations || '[]');
                setActiveTool('move');
                redrawCanvas();
                annotationModal.dataset.targetPreviewId = previewImgId;
                annotationModal.showModal();
            };
        
            baseImage.onerror = (e) => {
                alert("Impossible de charger l'image pour l'annotation. Erreur de source.");
                console.error("Erreur de chargement de l'image dans `baseImage`:", e);
            };
        
            baseImage.src = objectURL;
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(baseImage, 0, 0);
            annotations.forEach(drawAnnotation);
            if (isDrawing && currentAnnotation) {
                drawAnnotation(currentAnnotation);
            }
            if (selectedAnnotation) {
                drawSelectionBorder(selectedAnnotation);
            }
        }

        function drawSelectionBorder(annotation) {
            ctx.save();
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            let centerX, centerY;
            let x, y, width, height;

            if (annotation.type === 'location') {
                x = annotation.x - annotation.radius;
                y = annotation.y - annotation.radius;
                width = annotation.radius * 2;
                height = annotation.radius * 2;
                centerX = annotation.x;
                centerY = annotation.y;
            } else if (annotation.type === 'box') {
                x = annotation.x;
                y = annotation.y;
                width = annotation.width;
                height = annotation.height;
                centerX = annotation.x + annotation.width / 2;
                centerY = annotation.y + annotation.height / 2;
            } else if (annotation.type === 'arrow') {
                const minX = Math.min(annotation.startX, annotation.endX);
                const minY = Math.min(annotation.startY, annotation.endY);
                const maxX = Math.max(annotation.startX, annotation.endX);
                const maxY = Math.max(annotation.startY, annotation.endY);
                x = minX - 10;
                y = minY - 10;
                width = maxX - minX + 20;
                height = maxY - minY + 20;
                centerX = (annotation.startX + annotation.endX) / 2;
                centerY = (annotation.startY + annotation.endY) / 2;
            }

            if (annotation.rotation) {
                ctx.translate(centerX, centerY);
                ctx.rotate(annotation.rotation);
                ctx.translate(-centerX, -centerY);
            }
            
            ctx.strokeRect(x, y, width, height);
            ctx.restore();
        }

        function drawAnnotation(annotation) {
            ctx.save();
            let centerX, centerY;
            if (annotation.type === 'location') {
                centerX = annotation.x;
                centerY = annotation.y;
            } else if (annotation.type === 'box') {
                centerX = annotation.x + annotation.width / 2;
                centerY = annotation.y + annotation.height / 2;
            } else if (annotation.type === 'arrow') {
                centerX = (annotation.startX + annotation.endX) / 2;
                centerY = (annotation.startY + annotation.endY) / 2;
            }

            if (annotation.rotation) {
                ctx.translate(centerX, centerY);
                ctx.rotate(annotation.rotation);
                ctx.translate(-centerX, -centerY);
            }

            switch (annotation.type) {
                case 'location': {
                    const radius = annotation.radius || 0;
                    if (radius < 2) {
                        ctx.restore();
                        return;
                    }
                    ctx.beginPath();
                    ctx.arc(annotation.x, annotation.y, radius, 0, 2 * Math.PI);
                    ctx.fillStyle = `rgba(91, 155, 213, ${annotation.opacity || 0.5})`;
                    ctx.fill();
                    ctx.strokeStyle = '#5b9bd5';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    if (annotation.text) {
                        ctx.fillStyle = 'black';
                        ctx.font = `bold ${Math.max(12, radius / 2)}px Oswald`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(annotation.text, annotation.x, annotation.y);
                    }
                    break;
                }
                case 'arrow': {
                    drawArrow(annotation.startX, annotation.startY, annotation.endX, annotation.endY, annotation.thickness || 5);
                    break;
                }
                case 'box': {
                    ctx.strokeStyle = '#c0392b';
                    ctx.lineWidth = annotation.thickness || 5;
                    ctx.strokeRect(annotation.x, annotation.y, annotation.width, annotation.height);
                    break;
                }
            }
            ctx.restore();
        }

        function drawArrow(fromx, fromy, tox, toy, lineWidth) {
            if (fromx === tox && fromy === toy) return;
            
            ctx.strokeStyle = '#c0392b';
            ctx.fillStyle = '#c0392b';
            ctx.lineWidth = lineWidth;
            
            const dx = tox - fromx;
            const dy = toy - fromy;
            const angle = Math.atan2(dy, dx);
            const headlen = Math.max(lineWidth * 3, 10); 
            const arrowLength = Math.sqrt(dx * dx + dy * dy);

            const lineToX = tox - (headlen * 0.7) * Math.cos(angle);
            const lineToY = toy - (headlen * 0.7) * Math.sin(angle);
            
            if (arrowLength < headlen * 1.5) {
                ctx.beginPath();
                ctx.moveTo(fromx, fromy);
                ctx.lineTo(tox, toy);
                ctx.stroke();
                return;
            }

            ctx.beginPath();
            ctx.moveTo(fromx, fromy);
            ctx.lineTo(lineToX, lineToY);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(tox, toy);
            ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 7), toy - headlen * Math.sin(angle - Math.PI / 7));
            ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 7), toy - headlen * Math.sin(angle + Math.PI / 7));
            ctx.closePath();
            ctx.fill();
        }

        function getEventPos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            // Utiliser une vérification plus robuste pour l'événement tactile
            const clientX = evt.touches && evt.touches.length > 0 ? evt.touches[0].clientX : evt.clientX;
            const clientY = evt.touches && evt.touches.length > 0 ? evt.touches[0].clientY : evt.clientY;
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function getRotatedPoint(x, y, centerX, centerY, angle) {
            const cos = Math.cos(-angle);
            const sin = Math.sin(-angle);
            const translatedX = x - centerX;
            const translatedY = y - centerY;
            return {
                x: translatedX * cos - translatedY * sin + centerX,
                y: translatedX * sin + translatedY * cos + centerY
            };
        }

        function getAnnotationAtPosition(x, y) {
            for (let i = annotations.length - 1; i >= 0; i--) {
                const annotation = annotations[i];
                const angle = annotation.rotation || 0;
                let centerX, centerY;
                
                if (annotation.type === 'location') { centerX = annotation.x; centerY = annotation.y; } 
                else if (annotation.type === 'box') { centerX = annotation.x + annotation.width / 2; centerY = annotation.y + annotation.height / 2; } 
                else if (annotation.type === 'arrow') { centerX = (annotation.startX + annotation.endX) / 2; centerY = (annotation.startY + annotation.endY) / 2; }

                // Pour des annotations simples (non textuelles), le centre de rotation est le centre de l'objet
                const rotatedPos = getRotatedPoint(x, y, centerX, centerY, angle);
                const testX = rotatedPos.x;
                const testY = rotatedPos.y;

                const tolerance = 15;
                let isInside = false;

                switch (annotation.type) {
                    case 'location':
                        isInside = Math.sqrt(Math.pow(testX - annotation.x, 2) + Math.pow(testY - annotation.y, 2)) <= annotation.radius + tolerance / 2;
                        break;
                    case 'box':
                        isInside = testX >= annotation.x - tolerance && testX <= annotation.x + annotation.width + tolerance &&
                            testY >= annotation.y - tolerance && testY <= annotation.y + annotation.height + tolerance;
                        break;
                    case 'arrow':
                        const dx = annotation.endX - annotation.startX;
                        const dy = annotation.endY - annotation.startY;
                        const lenSq = dx * dx + dy * dy;
                        if (lenSq === 0) break;
                        const t = ((testX - annotation.startX) * dx + (testY - annotation.startY) * dy) / lenSq;
                        const projX = annotation.startX + t * dx;
                        const projY = annotation.startY + t * dy;
                        if (t >= 0 && t <= 1) {
                            // Vérification de la distance au carré de la position du clic à la ligne projetée
                            const distSq = Math.pow(testX - projX, 2) + Math.pow(testY - projY, 2);
                            isInside = distSq <= Math.pow(annotation.thickness + tolerance, 2);
                        } else {
                            // Vérification si l'on est proche des extrémités (pour les flèches courtes)
                            const distStartSq = Math.pow(testX - annotation.startX, 2) + Math.pow(testY - annotation.startY, 2);
                            const distEndSq = Math.pow(testX - annotation.endX, 2) + Math.pow(testY - annotation.endY, 2);
                            const maxDistSq = Math.pow(annotation.thickness + tolerance, 2);
                            isInside = distStartSq <= maxDistSq || distEndSq <= maxDistSq;
                        }
                        break;
                }

                if (isInside) return annotation;
            }
            return null;
        }

        function handleDrawStart(e) {
            e.preventDefault();
            const pos = getEventPos(canvas, e);
            startX = pos.x;
            startY = pos.y;
            if (currentTool === 'move') {
                selectedAnnotation = getAnnotationAtPosition(pos.x, pos.y);
                setContextualTools(selectedAnnotation);
                if (selectedAnnotation) {
                    isMovingAnnotation = true; 
                    document.body.style.overflow = 'hidden';
                    redrawCanvas(); 
                }
            } else {
                isDrawing = true;
                selectedAnnotation = null;
                setContextualTools(null);
                currentAnnotation = {
                    type: currentTool,
                    startX: startX,
                    startY: startY,
                    endX: startX,
                    endY: startY,
                    rotation: 0
                };
            }
        }

        function handleDrawMove(e) {
            e.preventDefault();
            if (!isDrawing && !isMovingAnnotation) return; 
            const pos = getEventPos(canvas, e);
            
            if (isMovingAnnotation && selectedAnnotation) {
                const deltaX = pos.x - startX;
                const deltaY = pos.y - startY;

                if (selectedAnnotation.type === 'arrow') {
                    selectedAnnotation.startX += deltaX;
                    selectedAnnotation.startY += deltaY;
                    selectedAnnotation.endX += deltaX;
                    selectedAnnotation.endY += deltaY;
                } else {
                    // Pour box et location, x/y représente le coin ou le centre, on les déplace directement.
                    selectedAnnotation.x += deltaX;
                    selectedAnnotation.y += deltaY;
                }
                
                startX = pos.x;
                startY = pos.y;
                redrawCanvas();

            } else if (isDrawing && currentAnnotation) {
                currentAnnotation.endX = pos.x;
                currentAnnotation.endY = pos.y;
                redrawCanvas();
            }
        }

        function handleDrawEnd(e) {
            e.preventDefault();
            document.body.style.overflow = '';
            if (isMovingAnnotation) {
                isMovingAnnotation = false;
                redrawCanvas();
            } else if (isDrawing) {
                isDrawing = false;
                const final = { ...currentAnnotation };
                if (final.type === 'box') {
                    // Normaliser les coordonnées pour la boîte
                    final.x = Math.min(final.startX, final.endX);
                    final.y = Math.min(final.startY, final.endY);
                    final.width = Math.abs(final.startX - final.endX);
                    final.height = Math.abs(final.startY - final.endY);
                    final.thickness = document.getElementById('box_thickness').value;
                    if (final.width < 5 || final.height < 5) return;
                } else if (final.type === 'arrow') {
                    final.thickness = document.getElementById('arrow_thickness').value;
                    if (Math.abs(final.startX - final.endX) < 5 && Math.abs(final.startY - final.endY) < 5) return;
                } else if (final.type === 'location') {
                    // Utiliser le point de départ comme centre (x/y)
                    final.x = final.startX;
                    final.y = final.startY;
                    // Le rayon est la distance entre start et end
                    final.radius = Math.sqrt(Math.pow(final.endX - final.startX, 2) + Math.pow(final.endY - final.startY, 2));
                    final.text = document.getElementById('circle_text').value || 'Zone';
                    final.opacity = document.getElementById('circle_opacity').value;
                    if (final.radius < 5) return;
                }
                annotations.push(final);
                currentAnnotation = null;
                selectedAnnotation = final; 
                setContextualTools(selectedAnnotation);
                redrawCanvas();
            }
        }
        
        async function createAnnotatedImageBlob(imageBlob, annotationsData) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const objectURL = URL.createObjectURL(imageBlob);
                img.src = objectURL;
        
                img.onload = () => {
                    URL.revokeObjectURL(objectURL); 
                    tempCanvas.width = img.naturalWidth;
                    tempCanvas.height = img.naturalHeight;
                    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.drawImage(img, 0, 0);
        
                    annotationsData.forEach(annotation => drawAnnotationOnContext(tempCtx, img.naturalWidth, img.naturalHeight, annotation));
        
                    // CORRECTION: Utiliser PNG pour l'image annotée afin de conserver la transparence
                    tempCanvas.toBlob(blob => {
                        if (blob) {
                            resolve(blob);
                        } else {
                            reject(new Error('La conversion du canevas en Blob a échoué.'));
                        }
                    }, 'image/png'); 
                };
        
                img.onerror = (e) => {
                    URL.revokeObjectURL(objectURL);
                    reject(new Error(`Impossible de charger l'image depuis le Blob : ${e.message}`));
                };
            });
        }
        
        function drawAnnotationOnContext(context, canvasWidth, canvasHeight, annotation) {
            context.save();
            let centerX, centerY;
            if (annotation.type === 'location') {
                centerX = annotation.x;
                centerY = annotation.y;
            } else if (annotation.type === 'box') {
                centerX = annotation.x + annotation.width / 2;
                centerY = annotation.y + annotation.height / 2;
            } else if (annotation.type === 'arrow') {
                centerX = (annotation.startX + annotation.endX) / 2;
                centerY = (annotation.startY + annotation.endY) / 2;
            }
            
            if (annotation.rotation) {
                context.translate(centerX, centerY);
                context.rotate(annotation.rotation);
                context.translate(-centerX, -centerY);
            }

            switch (annotation.type) {
                case 'location': {
                    const radius = annotation.radius || 0;
                    if (radius < 2) { context.restore(); return; }
                    context.beginPath(); context.arc(annotation.x, annotation.y, radius, 0, 2 * Math.PI);
                    context.fillStyle = `rgba(91, 155, 213, ${annotation.opacity || 0.5})`; context.fill();
                    context.strokeStyle = '#5b9bd5'; context.lineWidth = 2; context.stroke();
                    if (annotation.text) {
                        context.fillStyle = 'black'; context.font = `bold ${Math.max(12, radius / 2)}px Oswald`;
                        context.textAlign = 'center'; context.textBaseline = 'middle';
                        context.fillText(annotation.text, annotation.x, annotation.y);
                    }
                    break;
                }
                case 'arrow': {
                    const drawArrowLocal = (fromx, fromy, tox, toy, lineWidth) => {
                         if (fromx === tox && fromy === toy) return;
                         context.strokeStyle = '#c0392b'; context.fillStyle = '#c0392b'; context.lineWidth = lineWidth;
                         const headlen = Math.max(lineWidth * 3, 10); 
                         const dx = tox - fromx; const dy = toy - fromy;
                         const angle = Math.atan2(dy, dx);
                         const lineToX = tox - (headlen * 0.7) * Math.cos(angle);
                         const lineToY = toy - (headlen * 0.7) * Math.sin(angle);
                         
                         context.beginPath(); context.moveTo(fromx, fromy); context.lineTo(lineToX, lineToY); context.stroke();
                         context.beginPath(); context.moveTo(tox, toy);
                         context.lineTo(tox - headlen * Math.cos(angle - Math.PI / 7), toy - headlen * Math.sin(angle - Math.PI / 7));
                         context.lineTo(tox - headlen * Math.cos(angle + Math.PI / 7), toy - headlen * Math.sin(angle + Math.PI / 7));
                         context.closePath(); context.fill();
                    };
                    drawArrowLocal(annotation.startX, annotation.startY, annotation.endX, annotation.endY, annotation.thickness || 5);
                    break;
                }
                case 'box': {
                    context.strokeStyle = '#c0392b'; context.lineWidth = annotation.thickness || 5;
                    context.strokeRect(annotation.x, annotation.y, annotation.width, annotation.height);
                    break;
                }
            }
            context.restore();
        }

        function checkCoherence() {
            // Utilisation de la clé isolée
            const dataString = localStorage.getItem(LOCAL_STORAGE_KEY);
            const formData = JSON.parse(dataString || '{}');
            const getVal = (id) => formData[id] || '';
            const alerts = [];
            const members = (formData.patracdvr_rows || []).flatMap(row => row.members);
            const indiaMembers = members.filter(m => m.cellule && m.cellule.toLowerCase().startsWith('india'));
            const aoMembers = members.filter(m => m.cellule && m.cellule.toLowerCase().startsWith('ao'));
            const allAssignedMembers = [...indiaMembers, ...aoMembers];

            if (!getVal('date_op')) { alerts.push("La Date de l'opération est manquante. <span class='material-symbols-outlined'>event</span>"); }

            if (!getVal('nom_adversaire')) { alerts.push("Le Nom de l'adversaire Principal est manquant. (Onglet 2) <span class='material-symbols-outlined'>person</span>"); }
            
            if (getVal('nom_adversaire_2') && !getVal('domicile_adversaire_2')) {
                 alerts.push(`Le Domicile de l'adversaire Secondaire est manquant. (Onglet 2) <span class='material-symbols-outlined'>home</span>`);
            }
            
            allAssignedMembers.forEach(member => {
                const hasNoPrimary = member.principales === 'Sans' || !member.principales;
                const hasNoSecondary = member.secondaires === 'Sans' || !member.secondaires;
                
                if (hasNoPrimary && hasNoSecondary && member.fonction !== 'Sans') {
                    alerts.push(`Membre ${member.trigramme} est assigné mais n'a AUCUN armement principal/secondaire. (Cellule: ${member.cellule}) <span class='material-symbols-outlined'>local_fire_department</span>`);
                }
                if (member.afis !== 'Sans' && !member.afis) {
                    alerts.push(`Membre ${member.trigramme} a un AFI non spécifié. <span class='material-symbols-outlined'>handgun</span>`);
                }
            });

            const chefInter = allAssignedMembers.find(m => m.fonction === 'Chef inter');
            if (chefInter && !chefInter.cellule.toLowerCase().startsWith('india')) {
                 alerts.push(`Le Chef inter (${chefInter.trigramme}) est assigné à la cellule ${chefInter.cellule} au lieu d'India. <span class='material-symbols-outlined'>group</span>`);
            }

            if (!formData.time_events || formData.time_events.length < 3) {
                alerts.push(`La Chronologie (T0, T1, T4...) est incomplète. Au moins 3 étapes sont recommandées. (Onglet 5) <span class='material-symbols-outlined'>timeline</span>`);
            } else {
                 const t4 = formData.time_events.find(e => e.type === 'T4');
                 if (!t4) alerts.push("Le TOP ACTION (T4) n'est pas défini dans la chronologie. <span class='material-symbols-outlined'>timer</span>");
            }

            const unassignedCount = (formData.patracdvr_unassigned || []).length;
            if (unassignedCount > 0) {
                 alerts.push(`${unassignedCount} membres ne sont PAS assignés à un véhicule/équipe. <span class='material-symbols-outlined'>groups_2</span>`);
            }
            
            coherenceAlertsContainer.innerHTML = '';
            if (alerts.length > 0) {
                alerts.forEach(alertText => {
                    const alertDiv = document.createElement('div');
                    alertDiv.className = 'coherence-alert';
                    alertDiv.innerHTML = `<span class="material-symbols-outlined">error</span> ${alertText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}`;
                    coherenceAlertsContainer.appendChild(alertDiv);
                });
            } else {
                coherenceAlertsContainer.innerHTML = `<div class="coherence-alert" style="background-color: var(--success-green); color: #000000;"><span class="material-symbols-outlined">check_circle</span> Aucune incohérence majeure détectée. Prêt à générer.</div>`;
            }

            let recapHtml = '<h4>Synthèse des Éléments Clés :</h4><ul>';
            recapHtml += `<li>Opération du ${getVal('date_op') || 'N/A'} - H: ${getVal('heure_execution') || 'N/A'}</li>`;
            recapHtml += `<li>Objectif 1 : ${getVal('nom_adversaire') || 'N/A'}</li>`;
            if (getVal('nom_adversaire_2')) {
                recapHtml += `<li>Objectif 2 : ${getVal('nom_adversaire_2') || 'N/A'}</li>`;
            }
            recapHtml += `<li>Équipe INDIA : ${indiaMembers.map(m => m.trigramme).join(', ') || 'N/A'}</li>`;
            recapHtml += `<li>Équipe AO : ${aoMembers.map(m => m.trigramme).join(', ') || 'N/A'}</li>`;
            recapHtml += `<li>Hypothèses : H1 (${getVal('hypothese_h1').substring(0, 30)}...)</li>`;
            recapHtml += '</ul>';
            recapFinalisation.innerHTML = recapHtml;

            return alerts.length === 0;
        }

        // Nouvelle fonction pour initialiser les écouteurs de drag-and-drop sur les conteneurs statiques
        function initializeDragDropListeners() {
            // Conteneurs statiques (uniquement ceux qui existent au chargement initial)
            const staticDropContainers = [
                document.getElementById('unassigned_members_container'),
                document.getElementById('trashCan')
            ].filter(Boolean);

            staticDropContainers.forEach(container => {
                container.addEventListener('dragenter', handleDragEnter);
                container.addEventListener('dragleave', handleDragLeave);
                container.addEventListener('dragover', handleDragOver); 
                container.addEventListener('drop', handleDrop);
            });
            
            // Écouteur global pour le dragover des éléments de temps (à l'intérieur de leur conteneur)
            document.getElementById('time_events_container').addEventListener('dragover', e => {
                e.preventDefault();
                const draggedId = e.dataTransfer.getData('text/plain');
                const draggedItem = document.getElementById(draggedId);
                const targetContainer = e.currentTarget;
                
                if (draggedItem && draggedItem.classList.contains('time-item')) {
                    // Utiliser getDragAfterElement pour les éléments de temps (même fonction, mais ciblant la liste)
                    const afterElement = getDragAfterElement(targetContainer, e.clientY);
                    
                    if (afterElement == null) { 
                        targetContainer.appendChild(draggedItem); 
                    } else { 
                        targetContainer.insertBefore(draggedItem, afterElement); 
                    }
                    saveFormData(); // Sauvegarder l'ordre après le déplacement
                }
            });
        }
        
        // --- NOUVEAU: Logique Fullscreen et Thème ---

        function isFullscreen() {
            return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
        }

        function toggleFullscreen() {
            const icon = document.getElementById('fullscreenIcon');
            if (!isFullscreen()) {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.mozRequestFullScreen) { /* Firefox */
                    document.documentElement.mozRequestFullScreen();
                } else if (document.documentElement.webkitRequestFullscreen) { /* Chrome, Safari and Opera */
                    document.documentElement.webkitRequestFullscreen();
                } else if (document.documentElement.msRequestFullscreen) { /* IE/Edge */
                    document.documentElement.msRequestFullscreen();
                }
                icon.textContent = 'fullscreen_exit';
                icon.title = 'Quitter le plein écran';
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) { /* Firefox */
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) { /* Chrome, Safari and Opera */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE/Edge */
                    document.msExitFullscreen();
                }
                icon.textContent = 'fullscreen';
                icon.title = 'Plein écran';
            }
        }
        
        function updateFullscreenIcon() {
            const icon = document.getElementById('fullscreenIcon');
            if (icon) {
                 if (isFullscreen()) {
                    icon.textContent = 'fullscreen_exit';
                    icon.title = 'Quitter le plein écran';
                 } else {
                    icon.textContent = 'fullscreen';
                    icon.title = 'Plein écran';
                 }
            }
        }

        function handleThemeToggle() {
            document.body.classList.toggle('light-mode'); 
            document.body.classList.toggle('dark-mode');
            const isDarkMode = document.body.classList.contains('dark-mode');
            localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
            document.getElementById('darkModeIcon').textContent = isDarkMode ? 'nightlight' : 'clear_day';
        }

        // --- Fin Logique Fullscreen et Thème ---


        document.addEventListener('DOMContentLoaded', async () => {
            
            try {
                // Initialiser IndexedDB en premier
                await dbManager.init();
            } catch (e) {
                alert("Votre navigateur ne supporte pas IndexedDB, ou son utilisation est bloquée. La gestion des photos ne fonctionnera pas.");
                console.error(e);
                return;
            }
            
            await loadFormData();
            
            // Initialisation du thème
            const isDarkMode = localStorage.getItem('theme') === 'dark' || !localStorage.getItem('theme');
            if (!isDarkMode) { document.body.classList.replace('dark-mode', 'light-mode'); }
            document.getElementById('darkModeIcon').textContent = isDarkMode ? 'nightlight' : 'clear_day';

            // Initialisation du dock
            const fullscreenToggleBtn = document.getElementById('fullscreenToggle');
            const darkModeToggleBtn = document.getElementById('darkModeToggle');
            if (fullscreenToggleBtn) {
                 fullscreenToggleBtn.addEventListener('click', toggleFullscreen);
                 document.addEventListener('fullscreenchange', updateFullscreenIcon);
                 document.addEventListener('webkitfullscreenchange', updateFullscreenIcon);
                 document.addEventListener('mozfullscreenchange', updateFullscreenIcon);
                 document.addEventListener('msfullscreenchange', updateFullscreenIcon);
                 updateFullscreenIcon(); // S'assurer que l'icône initiale est correcte
            }
            if (darkModeToggleBtn) {
                 darkModeToggleBtn.addEventListener('click', handleThemeToggle);
            }
            
            // Réinitialisation/Chargement des chips après loadFormData
            const formData = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY)) || {};
            initChipContainer('etat_esprit_container', formData.etat_esprit_list || []);
            initChipContainer('volume_adversaire_container', formData.volume_list || []);
            initChipContainer('etat_esprit_container_2', formData.etat_esprit_list_2 || []);
            initChipContainer('volume_adversaire_container_2', formData.volume_list_2 || []);

            setupQuickEditPanel(); 
            initializeDragDropListeners(); // Initialiser les écouteurs de drop statiques

            // Écouteur pour les collapsibles
            document.querySelector('.container').addEventListener('click', (event) => {
                const header = event.target.closest('.collapsible-header');
                if (header) { const container = header.parentElement; if (container && container.classList.contains('collapsible-container')) { container.classList.toggle('open'); } }
            });
            
            // Écouteur délégué pour la sélection de membre (pour le panneau desktop)
            document.querySelector('.container').addEventListener('click', (e) => {
                if (e.target.closest('.patracdvr-member-btn')) {
                    handleMemberSelection(e);
                }
            });
            
            // Écouteur pour le bouton de sauvegarde du panneau d'édition rapide (desktop)
            document.getElementById('saveQuickEditBtn').addEventListener('click', saveQuickEditChanges);

            // Ancienne logique de toggle theme déplacée dans le dock (handleThemeToggle)
            
            resetPatracdvrBtn.addEventListener('click', () => { 
                // Utilisation d'un `confirm` natif
                if (confirm("Voulez-vous vraiment effacer TOUS les véhicules et membres du PATRACDVR et vider la sauvegarde locale des membres ?")) { 
                    patracdvrContainer.innerHTML = ''; 
                    unassignedContainer.innerHTML = ''; 
                    saveFormData(); 
                    // Fermer le panneau d'édition si un membre est actif
                    activeMemberId = null;
                    document.getElementById('quickEditPanel').style.display = 'none';
                    alert("PATRACDVR réinitialisé.");
                } 
            });
            
            const vehicleCreationContainer = document.getElementById('vehicle_creation_buttons');
            availableVehicles.forEach(vehicle => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'add-btn add-vehicle-btn';
                btn.textContent = `➕ ${vehicle}`;
                btn.addEventListener('click', () => addPatracdvrRow(vehicle));
                vehicleCreationContainer.insertBefore(btn, document.getElementById('addManualVehicleBtn'));
            });

            document.getElementById('addManualVehicleBtn').addEventListener('click', addManualVehicle);
            document.getElementById('addManualMemberBtn').addEventListener('click', addManualMember);

            // Écouteur délégué pour les clics dans le panneau d'édition rapide (desktop)
            document.getElementById('quickEditPanel').addEventListener('click', (event) => {
                event.stopPropagation();
                const target = event.target;
                const quickEditButton = target.closest('.quick-edit-btn');
                
                if (quickEditButton && activeMemberId) {
                    const activeMember = document.getElementById(activeMemberId);
                    if (!activeMember) return;
                    const attribute = quickEditButton.dataset.attribute;
                    const value = quickEditButton.dataset.value;
                    
                    // Appliquer la valeur au dataset
                    activeMember.dataset[attribute] = value;
                    
                    // Logique de cohérence de base
                    if (attribute === 'cellule' && value === 'Sans') {
                        activeMember.dataset.fonction = 'Sans';
                    }
                    if (attribute === 'fonction' && value !== 'Sans' && activeMember.dataset.cellule === 'Sans') {
                        activeMember.dataset.cellule = 'India 1'; 
                    }
                    
                    // Mettre à jour les visuels
                    updateMemberButtonVisuals(activeMember);
                    
                    // Mettre à jour la sélection visuelle dans le panneau
                    const group = quickEditButton.parentElement;
                    group.querySelectorAll('.quick-edit-btn').forEach(btn => btn.classList.remove('selected'));
                    quickEditButton.classList.add('selected');
                    
                    saveFormData();
                } 
            });

            // Écouteur pour la mise à jour du trigramme (dans le panneau desktop)
            document.getElementById('quickEditPanel').addEventListener('input', (e) => {
                if (e.target.id === 'quick_edit_trigramme_input' && activeMemberId) {
                    const member = document.getElementById(activeMemberId);
                    member.dataset.trigramme = e.target.value.toUpperCase();
                    updateMemberButtonVisuals(member);
                    saveFormData();
                }
            });


            const quickEditModal = document.getElementById('quickEditModal');
            document.getElementById('quick_modal_closeBtn').addEventListener('click', () => {
                 quickEditModal.close();
                 // Désélectionner le membre actif si la modale est fermée
                 if (activeMemberId) {
                     const oldActive = document.getElementById(activeMemberId);
                     if (oldActive) oldActive.classList.remove('member-active');
                     activeMemberId = null;
                 }
            });
            // Écouteur délégué pour les clics dans la modale (mobile)
            quickEditModal.addEventListener('click', (event) => {
                const target = event.target.closest('.quick-edit-btn');
                if (!target || !activeMemberId) return;

                const activeMember = document.getElementById(activeMemberId);
                if (!activeMember) return;

                const attribute = target.dataset.attribute;
                const value = target.dataset.value;

                activeMember.dataset[attribute] = value;
                
                if (attribute === 'cellule' && value === 'Sans') {
                    activeMember.dataset.fonction = 'Sans';
                }
                if (attribute === 'fonction' && value !== 'Sans' && activeMember.dataset.cellule === 'Sans') {
                    activeMember.dataset.cellule = 'India 1';
                }
                
                updateMemberButtonVisuals(activeMember);
                
                const group = target.closest('.quick-edit-options');
                if(group) {
                    group.querySelectorAll('.quick-edit-btn').forEach(btn => btn.classList.remove('selected'));
                }
                target.classList.add('selected');

                saveFormData();
            });

            // --- Écouteurs de l'outil d'annotation ---
            canvas.addEventListener('mousedown', handleDrawStart); canvas.addEventListener('mousemove', handleDrawMove);
            canvas.addEventListener('mouseup', handleDrawEnd); canvas.addEventListener('mouseout', handleDrawEnd);
            canvas.addEventListener('touchstart', handleDrawStart, { passive: false }); 
            canvas.addEventListener('touchmove', handleDrawMove, { passive: false });
            canvas.addEventListener('touchend', handleDrawEnd);
            
            document.querySelectorAll('.toolbar-main-tools .tool-btn').forEach(btn => {
                btn.addEventListener('click', () => { const toolId = btn.id.split('_')[1]; if (['move', 'location', 'arrow', 'box'].includes(toolId)) setActiveTool(toolId); });
            });
            document.getElementById('tool_reset').addEventListener('click', () => { annotations = []; selectedAnnotation = null; setContextualTools(null); redrawCanvas();});
            document.getElementById('annotation_cancel').addEventListener('click', () => annotationModal.close());
            document.getElementById('annotation_save').addEventListener('click', () => {
                const targetId = annotationModal.dataset.targetPreviewId; 
                const previewImg = document.getElementById(targetId);
                if(previewImg) {
                    // S'assurer que les annotations de l'élément sélectionné sont enregistrées avant de sauvegarder le formulaire complet
                    if (selectedAnnotation) {
                        annotations = annotations.filter(ann => ann !== selectedAnnotation);
                        annotations.push(selectedAnnotation);
                    }
                    previewImg.dataset.annotations = JSON.stringify(annotations);
                }
                saveFormData(); 
                annotationModal.close();
            });
            
            rotationInput.addEventListener('change', updateAnnotationRotation);

            document.getElementById('delete_btn').addEventListener('click', () => { if(selectedAnnotation){ annotations = annotations.filter(ann => ann !== selectedAnnotation); selectedAnnotation = null; setContextualTools(null); redrawCanvas(); } });
            // Utilisation de `prompt` natif pour la saisie de texte simple
            document.getElementById('edit_text_btn').addEventListener('click', () => { 
                if(selectedAnnotation && selectedAnnotation.type === 'location'){ 
                    const newText = prompt('Modifier texte:', selectedAnnotation.text); 
                    if(newText !== null){ 
                        selectedAnnotation.text = newText; 
                        redrawCanvas(); 
                    } 
                } 
            });
            
            // CORRECTION: Utiliser la délégation d'événement sur le document pour dragstart/dragend
            document.addEventListener('dragstart', e => { 
                const target = e.target.closest('.patracdvr-member-btn, .time-item');
                if (target && target.classList.contains('draggable')) { 
                    e.dataTransfer.setData('text/plain', target.id);
                    // Utiliser setTimeout pour que la classe 'dragging' soit appliquée après le début du drag (meilleure compatibilité)
                    setTimeout(() => target.classList.add('dragging'), 0); 
                } 
            });

            document.addEventListener('dragend', (e) => { 
                 const draggedItem = e.target.closest('.draggable'); 
                 if (draggedItem) { 
                     draggedItem.classList.remove('dragging'); 
                     saveFormData(); // Sauvegarder l'état final du drag
                 } 
             });
            
            async function downloadOiPdf() {
                // CORRECTION: Assurer que PDFLib est disponible avant de continuer
                if (typeof PDFLib === 'undefined') { alert("Erreur: La bibliothèque PDF n'est pas encore chargée."); return; }
                const btn = downloadPdfBtn;
                const originalText = btn.textContent;
                btn.textContent = 'Génération en cours...'; btn.disabled = true;
                
                try {
                    const result = await buildPdf();
                    if (!result) { 
                        alert("La génération a échoué. Vérifiez vos données.");
                        return; 
                    }
                    const { pdfBytes, formData } = result;
                    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                    const url = URL.createObjectURL(blob);
                    
                    const getVal = (id) => formData[id] || 'RAS';
                    
                    const link = document.createElement('a');
                    let fileName = `OI_${getVal('date_op').replace(/[\/\\?%*:|"<>]/g, '-')}_${getVal('nom_adversaire').replace(/ /g, '_')}`;
                    if (getVal('nom_adversaire_2')) {
                        fileName += `_2nd_${getVal('nom_adversaire_2').replace(/ /g, '_')}`;
                    }
                    link.download = `${fileName}.pdf`;
                    link.href = url;
                    
                    document.body.appendChild(link); 
                    link.click(); 
                    document.body.removeChild(link);
                    
                    URL.revokeObjectURL(url);

                    // Supprimé alert bloquant.
                    
                } catch (error) {
                    console.error("Erreur critique lors de la génération du PDF:", error);
                    alert("Une erreur critique est survenue lors de la génération du PDF. Consultez la console (F12).");
                } finally {
                    btn.textContent = originalText; btn.disabled = false;
                }
            }

            function openPresentationMode() {
                const presentationContent = document.getElementById('presentation-content');
                
                if (!presentationModal) {
                    console.error("Modale 'presentationModal' non trouvée.");
                    return;
                }

                if(!checkCoherence()) {
                     alert("Attention: Des incohérences ont été détectées. Veuillez les vérifier dans la section Finalisation avant de générer.");
                }

                // CORRECTION: Ajout du contrôle du curseur pendant le chargement
                document.body.style.cursor = 'wait';

                presentationContent.innerHTML = '<h2>Chargement de l\'aperçu...</h2><p style="text-align:center;">Veuillez patienter pendant la compilation des images annotées.</p>';

                if(typeof presentationModal.showModal === 'function') {
                    presentationModal.showModal();
                } else {
                    presentationModal.style.display = 'block';
                }
                
                buildPresentationHtml().then(html => {
                    presentationContent.innerHTML = html;
                }).catch(err => {
                    console.error("Erreur lors de la construction de l'aperçu HTML:", err);
                    const dangerColor = document.body.classList.contains('dark-mode') ? '#c0392b' : '#c0392b';
                    presentationContent.innerHTML = '<h2>Erreur d\'affichage</h2><p style="color:' + dangerColor + ';">Une erreur est survenue lors de la compilation des images annotées pour l\'aperçu. Réessayez ou vérifiez la console.</p>';
                }).finally(() => {
                    document.body.style.cursor = 'default';
                });
            }

            previewBtn.addEventListener('click', openPresentationMode);
            downloadPdfBtn.addEventListener('click', downloadOiPdf);

            if (document.getElementById('closePresentationModalBtn')) {
                document.getElementById('closePresentationModalBtn').addEventListener('click', () => {
                    if (presentationModal) {
                         if(typeof presentationModal.close === 'function') {
                            presentationModal.close();
                        } else {
                            presentationModal.style.display = 'none';
                        }
                    }
                    // Désélectionner le membre actif si la modale est fermée
                    if (activeMemberId) {
                        const oldActive = document.getElementById(activeMemberId);
                        if (oldActive) oldActive.classList.remove('member-active');
                        activeMemberId = null;
                        if (window.innerWidth >= 768) {
                            document.getElementById('quickEditPanel').style.display = 'none';
                        }
                    }
                });
            }
            
            showStep(currentStep);
            
        });
        
        // --- PDF GENERATION LOGIC ---

        // NOUVEAU: Fonction pour charger l'image via fetch et la convertir en ArrayBuffer (pour la compression)
        async function fetchImageAndCompress(imagePath, quality) {
            try {
                // Utilisation de la fonction fetch standard pour charger les images
                const response = await fetch(imagePath);
                if (!response.ok) throw new Error(`Échec du chargement de l'image de fond: ${response.statusText}`);
                const blob = await response.blob();
                
                // Compression du Blob (qui est censé être un PNG comme demandé par l'utilisateur)
                return await compressImage(blob, quality); 
            } catch (error) {
                console.error(`Erreur de chargement/compression de l'image ${imagePath}:`, error);
                return null;
            }
        }

        function getAdversaryImageInfo(formData, adversaryIndex = 1) {
            const mainPhotoContainerId = adversaryIndex === 1 ? 'adversary_photo_preview_container' : 'adversary_photo_preview_container_2';
            if (formData.dynamic_photos && formData.dynamic_photos[mainPhotoContainerId]) {
                const firstImage = formData.dynamic_photos[mainPhotoContainerId][0];
                if (firstImage) {
                    return {
                        id: firstImage.id,
                        annotationsJson: firstImage.annotations || '[]'
                    };
                }
            }
            return null;
        }

        async function compressImage(imageBlob, quality) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const objectURL = URL.createObjectURL(imageBlob);
                img.src = objectURL;
        
                img.onload = () => {
                    URL.revokeObjectURL(objectURL); 
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
        
                    const MAX_DIMENSION = 1920;
                    let { naturalWidth: width, naturalHeight: height } = img;
                    if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
                        if (width > height) {
                            height = (MAX_DIMENSION / width) * height;
                            width = MAX_DIMENSION;
                        } else {
                            width = (MAX_DIMENSION / height) * width;
                            height = MAX_DIMENSION;
                        }
                    }
                    canvas.width = width;
                    canvas.height = height;

                    // CORRECTION: Pour les PNG (image de fond ou annotée), ne pas forcer le fond blanc
                    if (imageBlob.type !== 'image/png') {
                       ctx.fillStyle = 'white';
                       ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                    
                    ctx.drawImage(img, 0, 0, width, height);
        
                    canvas.toBlob(
                        (blob) => {
                            if (blob) {
                                resolve(blob.arrayBuffer());
                            } else {
                                reject(new Error('La conversion du canevas en Blob a échoué.'));
                            }
                        },
                        // Utiliser PNG si le Blob original était PNG (y compris les images annotées), JPEG sinon
                        (imageBlob.type === 'image/png' ? 'image/png' : 'image/jpeg'), 
                        quality
                    );
                };
                img.onerror = () => {
                    URL.revokeObjectURL(objectURL);
                    reject(new Error("Échec du chargement du Blob de l'image dans l'élément Image."));
                };
            });
        }

        async function buildPdf() {
            // CORRECTION: Vérification de PDFLib ici pour une erreur plus claire
            if (typeof PDFLib === 'undefined') { throw new Error("PDFLib non chargé."); }

            const { PDFDocument, StandardFonts, rgb, PageSizes } = PDFLib;
            const pdfDoc = await PDFDocument.create();
            let helveticaFont, helveticaBoldFont;
            try {
                helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
                helveticaBoldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
            } catch (e) {
                console.error("Erreur de chargement des polices PDF standard:", e);
                return null;
            }
        
            saveFormData();
            // Utilisation de la clé isolée
            const formDataString = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (!formDataString) { console.error("Aucune donnée à générer."); return null; }
            const formData = JSON.parse(formDataString);
        
            // --- Section de Compression Dynamique et de Chargement des Images ---
            const PDF_TARGET_SIZE_BYTES = 2.5 * 1024 * 1024;
            const TEXT_OVERHEAD_ESTIMATE = 150 * 1024; 
            
            const isDarkMode = document.body.classList.contains('dark-mode');
            const backgroundImagePath = isDarkMode ? BACKGROUND_IMAGE_DARK : BACKGROUND_IMAGE_LIGHT;
            
            const allImagesMeta = [];
            if (formData.dynamic_photos) {
                for (const category in formData.dynamic_photos) {
                    formData.dynamic_photos[category].forEach(imgMeta => allImagesMeta.push(imgMeta));
                }
            }
            
            // NOUVEAU: Ajout de l'image de fond système à la liste à compresser, avec un ID unique
            allImagesMeta.push({ id: BACKGROUND_IMAGE_ID, path: backgroundImagePath, isSystemBackground: true, annotationsJson: '[]' });


            let quality = 0.9;
            let compressedImages = {};
            let totalImageSize = 0;
        
            if (allImagesMeta.length > 0) {
                console.log("Début de la compression dynamique...");
                // Réduire la qualité jusqu'à 0.5 si la taille dépasse 2.5MB
                do {
                    totalImageSize = 0;
                    const compressionPromises = allImagesMeta.map(async (imgMeta) => {
                        let compressedBuffer = null;
                        
                        if (imgMeta.isSystemBackground) {
                            // Chargement et compression de l'image de fond
                            compressedBuffer = await fetchImageAndCompress(imgMeta.path, quality);
                        } else {
                            const originalBlob = await dbManager.getItem(imgMeta.id);
                            if (!originalBlob) return { id: imgMeta.id, buffer: null };
                            
                            let blobToCompress = originalBlob;
                            // Créer l'image annotée si des annotations existent
                            const annotations = JSON.parse(imgMeta.annotations || '[]');
                            if (annotations.length > 0) {
                                blobToCompress = await createAnnotatedImageBlob(originalBlob, annotations);
                            }
                            
                            compressedBuffer = await compressImage(blobToCompress, quality);
                        }

                        return { id: imgMeta.id, buffer: compressedBuffer };
                    });
                    
                    const results = await Promise.all(compressionPromises);
                    
                    compressedImages = {};
                    for (const result of results) {
                        if (result.buffer) {
                            compressedImages[result.id] = result.buffer;
                            totalImageSize += result.buffer.byteLength;
                        }
                    }
                    
                    console.log(`Qualité: ${quality.toFixed(1)}, Taille totale des images: ${(totalImageSize / 1024 / 1024).toFixed(2)}MB`);
                    
                    if (totalImageSize + TEXT_OVERHEAD_ESTIMATE < PDF_TARGET_SIZE_BYTES) {
                        break; 
                    }
                    
                    quality -= 0.1; 
                    
                } while (quality >= 0.5);

                if (totalImageSize + TEXT_OVERHEAD_ESTIMATE > PDF_TARGET_SIZE_BYTES) {
                    console.warn(`Avertissement: Le PDF généré pourrait dépasser 2.5Mo. La taille des images compressées est de ${(totalImageSize / 1024 / 1024).toFixed(2)}MB.`);
                }
            }
            // --- Fin de la Section de Compression ---

            const getVal = (id) => formData[id] || '';
            const context = {
                pdfDoc, helveticaFont, helveticaBoldFont,
                currentPage: null, y: 0, pageWidth: 0, pageHeight: 0, margin: 40,
                pageNumber: 0, 
                // CORRECTION: La couleur de fond est basée sur le thème
                colors: isDarkMode ? { background: rgb(30/255, 30/255, 30/255), text: rgb(1, 1, 1), accent: rgb(91/255, 155/255, 213/255), danger: rgb(192/255, 57/255, 43/255) } : { background: rgb(1, 1, 1), text: rgb(0, 0, 0), accent: rgb(0, 51/255, 160/255, 255), danger: rgb(192/255, 57/255, 43/255) }
            };
            let backgroundImage = null;
            
            // NOUVEAU: Chargement de l'image de fond compressée
            if (compressedImages[BACKGROUND_IMAGE_ID]) {
                try {
                    const imageBytes = compressedImages[BACKGROUND_IMAGE_ID];
                    // L'image de fond est censée être un PNG
                    backgroundImage = await pdfDoc.embedPng(imageBytes);
                } catch (e) { 
                    console.warn("L'image de fond n'a pas pu être intégrée (même après compression).", e);
                }
            }
            
            const addNewPage = (isFinalPage = false) => {
                context.currentPage = context.pdfDoc.addPage([PageSizes.A4[1], PageSizes.A4[0]]);
                context.pageNumber++; // Incrémente le compteur de page
                const { width, height } = context.currentPage.getSize();
                context.pageWidth = width; context.pageHeight = height; context.y = height - context.margin;
                
                // CORRECTION FOND BLANC: Dessine un fond plein sur toutes les pages pour éviter les bandes blanches
                context.currentPage.drawRectangle({ x: 0, y: 0, width, height, color: context.colors.background });
                
                // CORRECTION IMAGE: Dessine le filigrane uniquement sur la première page et si c'est la page finale
                if (backgroundImage && (context.pageNumber === 1 || isFinalPage)) { 
                    const scaled = backgroundImage.scaleToFit(width, height);
                    context.currentPage.drawImage(backgroundImage, { 
                        x: (width - scaled.width) / 2, 
                        y: (height - scaled.height) / 2, 
                        width: scaled.width, 
                        height: scaled.height,
                        // CONSIGNE: Opacité fixée à 1.0
                        opacity: 1.0
                    }); 
                }
            };
            const checkY = (spaceNeeded) => { 
                // Vérifier si la place est suffisante. On ne déclenche pas addNewPage si c'est la page 1 (titre).
                if (context.y - spaceNeeded < context.margin && context.pageNumber > 0) { 
                    addNewPage(); 
                    return true; 
                } 
                return false; 
            };
            const drawTitle = (text) => { checkY(30); context.currentPage.drawText(text, { x: context.margin, y: context.y, font: helveticaBoldFont, size: 18, color: context.colors.accent }); context.y -= 30; };
            const drawSubTitle = (text) => { if (checkY(25)) { context.y -= 10; } context.currentPage.drawText(text, { x: context.margin, y: context.y, font: helveticaBoldFont, size: 14, color: context.colors.accent }); context.y -= 25; };
            const wrapText = (text, font, size, maxWidth) => {
                const words = String(text || '').replace(/\n/g, ' \n ').split(' ');
                let lines = []; let currentLine = '';
                for (const word of words) {
                    if (word === '\n') { lines.push(currentLine); currentLine = ''; continue; }
                    const lineWithWord = currentLine === '' ? word : `${currentLine} ${word}`;
                    if (font.widthOfTextAtSize(lineWithWord, size) > maxWidth && currentLine !== '') { lines.push(currentLine); currentLine = word; } 
                    else { currentLine = lineWithWord; }
                }
                lines.push(currentLine); return lines;
            };
            const drawWrappedText = (text, options = {}) => {
                const { font = helveticaFont, size = 12, color = context.colors.text, x = context.margin + 15 } = options;
                const maxWidth = context.pageWidth - x - context.margin;
                const lines = wrapText(text, font, size, maxWidth);
                const totalHeight = lines.length * (size + 4);
                if (checkY(totalHeight + 10)) { context.y -= (size + 4); }
                lines.forEach((line, index) => { context.currentPage.drawText(line, { x, y: context.y - (index * (size + 4)), font, size, color }); });
                context.y -= (totalHeight + 10);
            };
            const drawTable = (headers, rows, columnWidths, startX) => {
                let currentY = context.y; const rowPadding = 5; const headerFontSize = 10; const contentFontSize = 10;
                const drawRow = (rowData, isHeader) => {
                    const font = isHeader ? helveticaBoldFont : helveticaFont; const size = isHeader ? headerFontSize : contentFontSize;
                    const cellContents = rowData.map((text, i) => wrapText(text, font, size, columnWidths[i] - 2 * rowPadding));
                    const maxLines = Math.max(...cellContents.map(lines => lines.length));
                    const rowHeight = maxLines * (size + 2) + 2 * rowPadding;
                    if (currentY - rowHeight < context.margin) { addNewPage(); currentY = context.y; drawRow(headers, true); }
                    currentY -= rowHeight; let currentX = startX;
                    rowData.forEach((_, i) => {
                        context.currentPage.drawRectangle({ x: currentX, y: currentY, width: columnWidths[i], height: rowHeight, borderColor: context.colors.accent, borderWidth: 0.5 });
                        const lines = cellContents[i];
                        lines.forEach((line, lineIndex) => { context.currentPage.drawText(line, { x: currentX + rowPadding, y: currentY + rowHeight - rowPadding - (lineIndex + 1) * (size + 4) + 2, font, size, color: context.colors.text }); });
                        currentX += columnWidths[i];
                    });
                };
                drawRow(headers, true); rows.forEach(row => drawRow(row, false)); context.y = currentY - 20;
            };
            
            const drawImagesFromCategory = async (previewContainerId, title) => {
                const imagesData = (formData.dynamic_photos || {})[previewContainerId] || [];
                for (let i = 0; i < imagesData.length; i++) {
                    const imgData = imagesData[i];
                    addNewPage();
                    try {
                        const imageBytes = compressedImages[imgData.id];
                        if (!imageBytes) throw new Error("Données d'image compressées non trouvées.");

                        let image;
                        try {
                            // Tente d'intégrer en PNG car toutes les images annotées sont PNG
                            if (JSON.parse(imgData.annotations || '[]').length > 0) {
                                image = await pdfDoc.embedPng(imageBytes);
                            } else { // Sinon tente JPG
                                image = await pdfDoc.embedJpg(imageBytes);
                            }
                        } catch (e) {
                            // Fallback si l'extension n'est pas fiable
                            try { image = await pdfDoc.embedPng(imageBytes); } catch (e2) { image = await pdfDoc.embedJpg(imageBytes); }
                        }
                        
                        const { width, height } = context.currentPage.getSize();
                        const paddedW = width - context.margin * 2; const paddedH = height - context.margin * 2 - 30;
                        const scaled = image.scaleToFit(paddedW, paddedH);
                        const x = (width - scaled.width) / 2; const y = (height - scaled.height) / 2 + 15;
                        context.currentPage.drawImage(image, { x, y, width: scaled.width, height: scaled.height });
                        const finalTitle = imagesData.length > 1 ? `${title} (${i+1})` : title;
                        const textWidth = helveticaBoldFont.widthOfTextAtSize(finalTitle, 14);
                        context.currentPage.drawText(finalTitle, { x: width / 2 - textWidth / 2, y: y - 20, font: helveticaBoldFont, size: 14, color: context.colors.text });
                    } catch (e) {
                        console.error(`Erreur d'intégration de l'image pour: ${title}`, e);
                        drawTitle("Erreur d'image"); drawWrappedText(`Impossible de charger une image.\n\nErreur: ${e.message}`);
                    }
                }
            };
            
            const getCompositionData = (teamPrefix) => {
                const membersByCell = {};
                const allMembers = (formData.patracdvr_rows || []).flatMap(row => row.members);
                
                allMembers.forEach(member => {
                    const cellule = member.cellule;
                    if (cellule && cellule.toLowerCase().startsWith(teamPrefix)) {
                        if (!membersByCell[cellule]) membersByCell[cellule] = [];
                        member.trigramme && membersByCell[cellule].push(member.trigramme);
                    }
                });

                const naturalSort = (a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
                const sortedKeys = Object.keys(membersByCell).sort(naturalSort);
                
                return sortedKeys.map(cell => ({ cell: cell, members: membersByCell[cell] }));
            };

            const drawCompositionList = (compositionData) => {
                const fontSize = 12;
                const lineHeight = fontSize + 4;
                if (checkY(lineHeight)) { context.y -= 10; }

                let currentX = context.margin + 15;
                const cellStyle = { font: helveticaBoldFont, color: context.colors.danger, size: fontSize };
                const trigrammeStyle = { font: helveticaBoldFont, color: context.colors.text, size: fontSize };
                const separatorStyle = { font: helveticaFont, color: context.colors.text, size: fontSize };
                
                compositionData.forEach((group, groupIndex) => {
                    const cellShortName = group.cell.toLowerCase().replace('india ', 'I').replace('ao', 'AO').toUpperCase();
                    
                    const groupParts = [{ text: cellShortName, style: cellStyle }, { text: ' : ', style: separatorStyle }];
                    group.members.forEach((member, memberIndex) => {
                        groupParts.push({ text: member, style: trigrammeStyle });
                        if (memberIndex < group.members.length - 1) {
                            groupParts.push({ text: ' - ', style: separatorStyle });
                        }
                    });
                     if (groupIndex < compositionData.length - 1) {
                        groupParts.push({ text: '    ', style: separatorStyle });
                    }

                    for(const part of groupParts) {
                        const partWidth = part.style.font.widthOfTextAtSize(part.text, part.style.size);
                        if (currentX + partWidth > context.pageWidth - context.margin) {
                            context.y -= lineHeight;
                            currentX = context.margin + 15;
                            if (checkY(lineHeight)) { context.y -= 10; }
                        }
                        context.currentPage.drawText(part.text, { x: currentX, y: context.y, ...part.style });
                        currentX += partWidth;
                    }
                });
                context.y -= (lineHeight + 10);
            };

            const drawAdversaryBlock = async (adversaryIndex) => {
                const suffix = adversaryIndex === 1 ? '' : '_2';
                const advName = getVal(`nom_adversaire${suffix}`);
                if (!advName) return;

                drawSubTitle(`ADVERSAIRE (OBJECTIF ${adversaryIndex}): ${advName}`);
                
                const imageInfo = getAdversaryImageInfo(formData, adversaryIndex);
                let isImagePresent = imageInfo !== null;
                const photoBoxWidth = 200;
                const photoBoxHeight = 220;
                const photoBoxX = context.pageWidth - context.margin - photoBoxWidth;
                const photoBoxMargin = 10;
                let topY = context.y; 
                
                let tableStartX = context.margin;
                let tableMaxWidth = context.pageWidth - context.margin * 2;
                
                if (isImagePresent) {
                    tableMaxWidth = photoBoxX - tableStartX - photoBoxMargin;
                }

                const meText = (formData[`me_list${suffix}`] || []).map((me, i) => `ME${i+1}: ${me}`).join(' | ');
                
                const adversaireHeaders = ["Information", "Détail"];
                
                const adversaireRows = [
                    ['Nom/Prénom', advName], 
                    ['Domicile', getVal(`domicile_adversaire${suffix}`)],
                    ['Naissance', `${getVal(`date_naissance${suffix}`)} à ${getVal(`lieu_naissance${suffix}`)}`],
                    ['Description', `${getVal(`stature_adversaire${suffix}`)} / ${getVal(`ethnie_adversaire${suffix}`)}`],
                    ['Signes particuliers', getVal(`signes_particuliers${suffix}`)], 
                    ['Profession', getVal(`profession_adversaire${suffix}`)],
                    ['Antécédents', getVal(`antecedents_adversaire${suffix}`)], 
                    ['État d\'esprit', (formData[`etat_esprit_list${suffix}`] || []).join(', ')],
                    ['Attitude', getVal(`attitude_adversaire${suffix}`)], 
                    ['Volume (renfort)', (formData[`volume_adversaire_container${suffix}`] || []).join(', ')],
                    ['Substances', getVal(`substances_adversaire${suffix}`)], 
                    ['Véhicules', (formData[`vehicules_list${suffix}`] || []).join(', ')],
                    ['Armes', getVal(`armes_connues${suffix}`)], 
                    ['Moyens Employés', meText],
                ].filter(row => row[1] && String(row[1]).trim() !== 'à' && String(row[1]).trim() !== 'N/A' && String(row[1]).trim() !== '');

                let photoBottomY = topY;
                let tableBottomY = topY;
                
                if (isImagePresent) {
                    const { id } = imageInfo;
                    const frameY = topY - photoBoxHeight; 
                    
                    try {
                        const imageBytes = compressedImages[id];
                        if (!imageBytes) throw new Error("Données d'image compressées pour l'adversaire non trouvées.");

                        let image;
                        try {
                            if (JSON.parse(imageInfo.annotations || '[]').length > 0) { image = await pdfDoc.embedPng(imageBytes); } else { image = await pdfDoc.embedJpg(imageBytes); }
                        } catch (e) {
                             try { image = await pdfDoc.embedPng(imageBytes); } catch (e2) { image = await pdfDoc.embedJpg(imageBytes); }
                        }
                        
                        const scaled = image.scaleToFit(photoBoxWidth - 10, photoBoxHeight - 30);
                        const imageY = frameY + (photoBoxHeight - scaled.height) / 2;

                        if(frameY >= context.margin) {
                            context.currentPage.drawRectangle({ x: photoBoxX, y: frameY, width: photoBoxWidth, height: photoBoxHeight, borderColor: context.colors.accent, borderWidth: 1 });
                            context.currentPage.drawImage(image, { x: photoBoxX + (photoBoxWidth - scaled.width) / 2, y: imageY, width: scaled.width, height: scaled.height });
                            const photoTitle = `Photo de l'objectif ${adversaryIndex}`;
                            const titleWidth = helveticaFont.widthOfTextAtSize(photoTitle, 10);
                            context.currentPage.drawText(photoTitle, { x: photoBoxX + (photoBoxWidth - titleWidth) / 2, y: frameY + 5, font: helveticaFont, size: 10, color: context.colors.text });
                            photoBottomY = frameY;
                        } else { isImagePresent = false; }
                    } catch (e) {
                        console.error(`Échec du traitement de la photo de l'adversaire ${adversaryIndex}:`, e);
                        isImagePresent = false; 
                    }
                }

                if (adversaireRows.length > 0) {
                    context.y = topY; 
                    drawTable(adversaireHeaders, adversaireRows, [150, tableMaxWidth - 150], tableStartX);
                    tableBottomY = context.y;
                } else {
                    tableBottomY = topY;
                }
                
                context.y = Math.min(tableBottomY, photoBottomY) - 20;

                const extraPhotoContainerId = adversaryIndex === 1 ? 'adversary_extra_photos_preview_container' : 'adversary_extra_photos_preview_container_2';
                await drawImagesFromCategory(extraPhotoContainerId, `Photo Supplémentaire - Adversaire ${adversaryIndex}`);

                if (adversaryIndex === 1) {
                    await drawImagesFromCategory('renforts_photo_preview_container', 'Photo - Renforts Potentiels');
                }
                
                checkY(50);
            }

            const pdfCreationLogic = async () => {
                // Initialisation de la première page (qui doit avoir le fond)
                addNewPage();
                
                // CONSIGNE: Titre en haut à gauche
                const mainTitle = "OI";
                context.currentPage.drawText(mainTitle, { 
                    x: context.margin, 
                    y: context.pageHeight - context.margin, 
                    font: helveticaBoldFont, 
                    size: 24, 
                    color: context.colors.accent 
                });
                
                // CONSIGNE: Date en haut à droite
                const dateTitle = `DU ${getVal('date_op') || '(DATE)'}`;
                const dateTitleWidth = helveticaBoldFont.widthOfTextAtSize(dateTitle, 18);
                context.currentPage.drawText(dateTitle, { 
                    x: context.pageWidth - context.margin - dateTitleWidth, 
                    y: context.pageHeight - context.margin - (24-18)*0.5, // Aligner verticalement avec le titre
                    font: helveticaBoldFont, 
                    size: 18, 
                    color: context.colors.text 
                });
                
                context.y = context.pageHeight - context.margin - 40; // Démarrer le contenu sous le titre
                
                addNewPage(); // Page 2
                drawTitle("1. SITUATION");
                drawSubTitle("1.1 Situation Générale"); drawWrappedText(getVal('situation_generale'), { size: 14 });
                drawSubTitle("1.2 Situation Particulière"); drawWrappedText(getVal('situation_particuliere'), { size: 14 });
                
                addNewPage(); // Page 3
                drawTitle("2. ADVERSAIRE(S)");
                
                await drawAdversaryBlock(1);
                
                if (getVal('nom_adversaire_2')) {
                    addNewPage();
                    drawTitle("2. ADVERSAIRE(S) (Suite)");
                    await drawAdversaryBlock(2);
                }


                addNewPage();
                drawTitle("3. ENVIRONNEMENT");
                drawSubTitle("Ami(e)s (soutien)"); drawWrappedText(getVal('amies'), { size: 14 });
                drawSubTitle("Terrain / Météo"); drawWrappedText(getVal('terrain_info'), { size: 14 });
                drawSubTitle("Population"); drawWrappedText(getVal('population'), { size: 14 });
                drawSubTitle("Cadre juridique"); drawWrappedText(getVal('cadre_juridique'), { size: 14 });
                
                await drawImagesFromCategory('photo_container_transport_pr_preview_container', 'Transport PSIG vers PR');
                await drawImagesFromCategory('photo_container_transport_domicile_preview_container', 'Transport PR vers Domicile/LE');
                await drawImagesFromCategory('photo_container_bapteme_terrain_preview_container', 'Baptême terrain');

                addNewPage();
                drawTitle("4. MISSION");
                drawWrappedText(getVal('missions_psig'), { font: helveticaBoldFont, size: 30, color: context.colors.danger, x: context.margin });

                addNewPage();
                drawTitle("5. EXÉCUTION");
                drawWrappedText(getVal('action_body_text'), { size: 16, x: context.margin }); 
                
                drawSubTitle("Chronologie des temps");
                const chronoHeaders = ["Type", "Heure", "Description"];
                const chronoRows = (formData.time_events || []).map(e => [e.type || 'N/A', e.hour || 'N/A', e.description || 'N/A']);
                drawTable(chronoHeaders, chronoRows, [80, 120, 550], context.margin);
                drawSubTitle("Hypothèses");
                const h1 = `H1: ${getVal('hypothese_h1')}`;
                const h2 = `H2: ${getVal('hypothese_h2')}`;
                const h3 = `H3: ${getVal('hypothese_h3')}`;
                drawWrappedText(`${h1}\n${h2}\n${h3}`, { size: 14, font: helveticaBoldFont, color: context.colors.danger });

                addNewPage();
                drawTitle("6. ARTICULATION");
                drawWrappedText(`Place du Chef (Générale): ${getVal('place_chef')}`, { size: 14, x: context.margin });
                drawSubTitle("Équipe INDIA (INTER)"); 
                drawSubTitle("Composition:"); drawCompositionList(getCompositionData('india'));
                drawSubTitle("Mission:"); drawWrappedText(getVal('india_mission'));
                drawSubTitle("Objectif:"); drawWrappedText(getVal('india_objectif')); drawSubTitle("Itinéraire:");
                drawWrappedText(getVal('india_itineraire')); drawSubTitle("Points Particuliers:"); drawWrappedText(getVal('india_points_particuliers'));
                drawSubTitle("Conduite à Tenir:"); drawWrappedText(getVal('india_cat'));
                
                await drawImagesFromCategory('photo_container_itineraire_exterieur_preview_container', 'Itinéraire Extérieur India');
                await drawImagesFromCategory('photo_container_itineraire_interieur_preview_container', 'Itinéraire Intérieur India');
                await drawImagesFromCategory('photo_container_cellule_effraction_preview_container', 'Cellule Effraction');
                
                addNewPage();
                drawTitle("6. ARTICULATION (Suite)");
                drawSubTitle("Équipe Appui/Observation (AO) - ZMSPCP"); 
                drawSubTitle("Composition:"); drawCompositionList(getCompositionData('ao'));
                drawSubTitle("Zone d'installation (Z):");
                drawWrappedText(getVal('ao_zone_installation')); drawSubTitle("Mission (M):"); drawWrappedText(getVal('ao_mission'));
                drawSubTitle("Secteur de surveillance (S):"); drawWrappedText(getVal('ao_secteur_surveillance'));
                drawSubTitle("Points Particuliers (P):"); drawWrappedText(getVal('ao_points_particuliers'));
                drawSubTitle("Place du Chef (P):"); drawWrappedText(getVal('ao_place_chef'));
                drawSubTitle("Conduite à Tenir (C):"); drawWrappedText(getVal('ao_cat'));

                await drawImagesFromCategory('photo_container_emplacement_ao_preview_container', 'Emplacement AO');
                
                addNewPage();
                drawTitle("7. PATRACDVR");
                const patracHeaders = ["Pax", "Fonction", "Cellule", "Princ.", "Sec.", "A.F.I.", "Grenades", "Équip. 1", "Équip. 2", "Tenue", "GPB"];
                for (const row of (formData.patracdvr_rows || [])) {
                    if(row.vehicle && row.members && row.members.length > 0) {
                        drawSubTitle(`Véhicule: ${row.vehicle}`);
                        const patracRows = row.members.filter(m => m.trigramme).map(m => [
                            m.trigramme, m.fonction, m.cellule, 
                            m.principales, m.secondaires, m.afis, m.grenades, 
                            m.equipement, m.equipement2, m.tenue, m.gpb
                        ]);
                        if (patracRows.length > 0) { 
                             drawTable(patracHeaders, patracRows, [60, 60, 60, 70, 60, 60, 60, 60, 60, 60, 60], context.margin); 
                        }
                    }
                }
                
                addNewPage();
                drawTitle("9. Conduites à tenir");
                drawSubTitle("Générales"); drawWrappedText(getVal('cat_generales'), {x: context.margin, font: helveticaBoldFont});
                const noGoText = getVal('no_go');
                if (noGoText) {
                    drawSubTitle("NO GO");
                    drawWrappedText(noGoText, { x: context.margin, font: helveticaBoldFont, size: 14.4, color: context.colors.danger });
                }
                drawSubTitle("Liaison"); drawWrappedText(getVal('cat_liaison'), {x: context.margin, font: helveticaBoldFont});

                
                // CORRECTION IMAGE: Ajoute la page finale AVEC le fond
                // Supprimer l'ancienne page finale
                context.pdfDoc.removePage(context.pdfDoc.getPageCount() - 1);
                context.pageNumber = context.pdfDoc.getPageCount(); // Réinitialise le compteur au nombre de pages avant la finale
                
                // Ajoute la page finale AVEC le fond
                addNewPage(true); 

                // CONSIGNE: Le texte "Avez vous des questions?" est centré dans le premier quart supérieur de la diapo.
                const finalText = "Avez vous des questions?";
                const finalTextWidth = helveticaBoldFont.widthOfTextAtSize(finalText, 48);
                
                // Y: Le premier quart est de context.pageHeight à context.pageHeight * 0.75.
                // Centré sur le point Y = (Max Y + Min Y) / 2 = (height + (height * 0.75)) / 2 = height * 0.875
                const targetY = context.pageHeight * 0.75; // Ajustement visuel dans le premier quart
                
                context.currentPage.drawText(finalText, { 
                    x: context.pageWidth / 2 - finalTextWidth / 2, 
                    y: targetY, 
                    font: helveticaBoldFont, 
                    size: 48, 
                    color: context.colors.accent 
                });
            };

            await pdfCreationLogic();
            const pdfBytes = await pdfDoc.save();
            return { pdfBytes, formData };
        }
        
        // --- PRESENTATION HTML LOGIC ---
        
        async function buildPresentationHtml() {
            saveFormData();
            // Utilisation de la clé isolée
            const formDataString = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (!formDataString) { return "<h2>Aucune donnée à présenter.</h2>"; }
            const formData = JSON.parse(formDataString);
            const getVal = (id) => formData[id] || '';
            const isDarkMode = document.body.classList.contains('dark-mode');
            
            const accentColor = isDarkMode ? '#5b9bd5' : '#0033a0';
            const primaryText = isDarkMode ? '#e0e0e0' : '#212529';
            const secondaryText = isDarkMode ? '#95a5a6' : '#6c757d';
            const dangerColor = '#c0392b';

            let htmlContent = `<div style="font-family: 'Oswald', sans-serif; color: ${primaryText};">`;

            const cleanText = (text) => String(text || '').replace(/\*\*(.*?)\*\*/g, '$1').trim();
            
            const wrapHtml = (text, tag = 'p', style = {}) => {
                const styleString = Object.entries(style).map(([key, value]) => `${key}:${value}`).join(';');
                const formattedText = String(text || '')
                    .replace(/\*\*/g, '') 
                    .replace(/\n/g, '<br>');
                return `<${tag} style="${styleString}">${formattedText}</${tag}>`;
            };

            const drawTitleHtml = (text) => wrapHtml(cleanText(text), 'h2', { 'color': accentColor, 'font-size': '1.8em', 'margin-top': '20px', 'padding-bottom': '5px', 'border-bottom': `2px solid ${accentColor}` });
            const drawSubTitleHtml = (text) => wrapHtml(cleanText(text), 'h3', { 'color': accentColor, 'font-size': '1.3em', 'margin-top': '15px', 'margin-bottom': '10px' });
            const drawTextHtml = (text, bold = false, color = primaryText, size = '1.1em', indent = '15px') => wrapHtml(text, 'p', { 'font-weight': bold ? '500' : '400', 'color': color, 'font-size': size, 'margin-bottom': '8px', 'padding-left': indent, 'white-space': 'pre-wrap' });
            
            const drawTableHtml = (headers, rows) => {
                let table = `<table style="width: 100%; border-collapse: collapse; margin-top: 15px; margin-bottom: 20px;">`;
                table += `<thead style="background-color: ${accentColor}; color: white;"><tr>`;
                headers.forEach(h => { table += `<th style="padding: 10px; border: 1px solid ${primaryText}; text-align: left;">${h}</th>`; });
                table += `</tr></thead><tbody>`;
                rows.forEach(row => {
                    table += `<tr style="background-color: ${isDarkMode ? '#2a2a2a' : '#f8f9fa'};">`;
                    row.forEach(cell => { 
                        const cellContent = String(cell || '').replace(/\*\*/g, '').replace(/\n/g, '<br>');
                        table += `<td style="padding: 10px; border: 1px solid ${secondaryText}; vertical-align: top;">${cellContent}</td>`; 
                    });
                    table += `</tr>`;
                });
                table += `</tbody></table>`;
                return table;
            };

            const drawImagesHtmlFromCategory = async (previewContainerId, title) => {
                let imageHtml = '';
                const imagesData = (formData.dynamic_photos || {})[previewContainerId] || [];

                for (let i = 0; i < imagesData.length; i++) {
                    const imgData = imagesData[i];
                    const annotations = JSON.parse(imgData.annotations || '[]');
                    const imageBlob = await dbManager.getItem(imgData.id);
            
                    if (!imageBlob) continue;
            
                    let finalImageBlob = imageBlob;
                    if (annotations.length > 0) {
                        try {
                            // On génère le Blob annoté
                            finalImageBlob = await createAnnotatedImageBlob(imageBlob, annotations).catch(e => imageBlob);
                        } catch (e) {
                            console.error(`Erreur de génération d'image annotée pour ${title} (index ${i}):`, e);
                        }
                    }
                    
                    const objectURL = URL.createObjectURL(finalImageBlob);
            
                    const finalTitle = imagesData.length > 1 ? `${title} (${i+1})` : title;
                    blockHtml += `<div style="text-align: center; margin: 20px 0; border: 1px solid ${accentColor}; padding: 10px; background-color: ${isDarkMode ? '#1e1e1e' : '#ffffff'};">`;
                    blockHtml += `<h4 style="color: ${accentColor}; margin-bottom: 10px; font-size: 1.1em;">${finalTitle}</h4>`;
                    // Utiliser onload pour révoquer l'URL après le chargement
                    blockHtml += `<img src="${objectURL}" alt="${finalTitle}" style="max-width: 100%; height: auto; border-radius: 4px; box-shadow: 0 4px 8px rgba(0,0,0,${isDarkMode ? 0.4 : 0.1});" onload="URL.revokeObjectURL(this.src)">`; 
                    blockHtml += `</div>`;
                }
                return imageHtml;
            };

            const getCompositionHtml = (teamPrefix) => {
                const allMembers = (formData.patracdvr_rows || []).flatMap(row => row.members);
                const membersByCell = {};
                
                allMembers.forEach(member => {
                    const cellule = member.cellule; 
                    if (cellule && cellule.toLowerCase().startsWith(teamPrefix) && member.trigramme) {
                        if (!membersByCell[cellule]) membersByCell[cellule] = [];
                        membersByCell[cellule].push(member);
                    }
                });

                const naturalSort = (a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
                const sortedKeys = Object.keys(membersByCell).sort(naturalSort);
                
                let compositionHtml = '<div style="padding-left: 15px; margin-bottom: 15px;">';
                sortedKeys.forEach(cell => {
                    const memberList = membersByCell[cell].map(m => {
                        const func = m.fonction && m.fonction !== 'Sans' ? ` (${m.fonction})` : '';
                        return `<span style="color:${primaryText}; font-weight:600;">${m.trigramme}${func}</span>`;
                    }).join(' • ');
                    compositionHtml += `<p style="margin-bottom: 5px;"><strong style="color: ${dangerColor}; font-size: 1.1em;">${cell.toUpperCase()}</strong> : ${memberList}</p>`;
                });
                compositionHtml += '</div>';
                return sortedKeys.length > 0 ? compositionHtml : drawTextHtml('Aucun membre assigné.', false, secondaryText);
            };

            const drawAdversaryBlockHtml = async (adversaryIndex) => {
                const suffix = adversaryIndex === 1 ? '' : '_2';
                const advName = getVal(`nom_adversaire${suffix}`);
                if (!advName) return '';

                let blockHtml = `<div style="margin-bottom: 30px; border-bottom: 1px dashed ${secondaryText}; padding-bottom: 20px;">`;
                blockHtml += drawSubTitleHtml(`ADVERSAIRE (OBJECTIF ${adversaryIndex}) : ${advName}`);
                
                const mainPhotoContainerId = adversaryIndex === 1 ? 'adversary_photo_preview_container' : 'adversary_photo_preview_container_2';
                const extraPhotoContainerId = adversaryIndex === 1 ? 'adversary_extra_photos_preview_container' : 'adversary_extra_photos_preview_container_2';
                
                // Photo principale
                const imageInfo = getAdversaryImageInfo(formData, adversaryIndex);
                    if (imageInfo) {
                    const imageBlob = await dbManager.getItem(imageInfo.id);
                    if (imageBlob) {
                        let finalImageBlob = imageBlob;
                        const annotations = JSON.parse(imageInfo.annotations || '[]');
                        if (annotations.length > 0) {
                            finalImageBlob = await createAnnotatedImageBlob(imageBlob, annotations).catch(e => imageBlob);
                        }
                        const objectURL = URL.createObjectURL(finalImageBlob);
                        
                        blockHtml += `<div style="text-align: center; margin-bottom: 15px;">
                                        <h4 style="color:${accentColor}; margin-bottom: 5px;">Photo Principale</h4>
                                        <img src="${objectURL}" alt="Photo de l'objectif ${adversaryIndex}" style="max-height: 250px; width: auto; border-radius: 4px;" onload="URL.revokeObjectURL(this.src)">
                                      </div>`;
                    }
                }
                
                const meText = (formData[`me_list${suffix}`] || []).map((me, i) => `ME${i+1}: ${me}`).join(' | ');
                const adversaireRows = [
                    ['Nom/Prénom', advName], 
                    ['Domicile', getVal(`domicile_adversaire${suffix}`)],
                    ['Naissance', `${getVal(`date_naissance${suffix}`)} à ${getVal(`lieu_naissance${suffix}`)}`],
                    ['Description', `${getVal(`stature_adversaire${suffix}`)} / ${getVal(`ethnie_adversaire${suffix}`)}`],
                    ['Signes particuliers', getVal(`signes_particuliers${suffix}`)], 
                    ['Profession', getVal(`profession_adversaire${suffix}`)],
                    ['Antécédents', getVal(`antecedents_adversaire${suffix}`)], 
                    ['État d\'esprit', (formData[`etat_esprit_list${suffix}`] || []).join(', ')],
                    ['Attitude (connue)', getVal(`attitude_adversaire${suffix}`)], 
                    ['Volume (renfort)', (formData[`volume_adversaire_container${suffix}`] || []).join(', ')],
                    ['Substances', getVal(`substances_adversaire${suffix}`)], 
                    ['Véhicules', (formData[`vehicules_list${suffix}`] || []).join(', ')],
                    ['Armes connues', getVal(`armes_connues${suffix}`)], 
                    ['Moyens Employés', meText],
                ].filter(row => row[1] && String(row[1]).trim() !== 'à' && String(row[1]).trim() !== 'N/A' && String(row[1]).trim() !== '');

                if (adversaireRows.length > 0) {
                    blockHtml += drawTableHtml(["Information", "Détail"], adversaireRows);
                } else {
                     blockHtml += drawTextHtml("Aucune information détaillée sur cet adversaire.", false, secondaryText);
                }
                
                blockHtml += await drawImagesHtmlFromCategory(extraPhotoContainerId, `Photos Supplémentaires ${adversaryIndex}`);

                blockHtml += `</div>`;
                return blockHtml;
            };


            
            
            htmlContent += drawTitleHtml(`Ordre Initial - ${getVal('nom_adversaire') || 'OPÉRATION'}`);
            htmlContent += drawTextHtml(`Date de l'opération : ${getVal('date_op') || 'N/A'}`, true, primaryText, '1.2em', '0');
            htmlContent += drawTitleHtml("1. SITUATION");
            htmlContent += drawSubTitleHtml("1.1 Situation Générale"); htmlContent += drawTextHtml(getVal('situation_generale'));
            htmlContent += drawSubTitleHtml("1.2 Situation Particulière"); htmlContent += drawTextHtml(getVal('situation_particuliere'));

            htmlContent += drawTitleHtml("2. ADVERSAIRE(S)");
            
            htmlContent += await drawAdversaryBlockHtml(1); 
            
            if (getVal('nom_adversaire_2')) {
                htmlContent += drawTitleHtml("2. ADVERSAIRE(S) - Suite");
                htmlContent += await drawAdversaryBlockHtml(2); 
            }
            
            htmlContent += await drawImagesHtmlFromCategory('renforts_photo_preview_container', 'Photos - Renforts Potentiels (Partagé)');

            htmlContent += drawTitleHtml("3. ENVIRONNEMENT");
            htmlContent += drawSubTitleHtml("Ami(e)s (soutien)"); htmlContent += drawTextHtml(getVal('amies'));
            htmlContent += drawSubTitleHtml("Terrain / Météo"); htmlContent += drawTextHtml(getVal('terrain_info'));
            htmlContent += drawSubTitleHtml("Population"); htmlContent += drawTextHtml(getVal('population'));
            htmlContent += drawSubTitleHtml("Cadre juridique"); htmlContent += drawTextHtml(getVal('cadre_juridique'));

            htmlContent += drawTitleHtml("4. MISSION DU PSIG");
            htmlContent += drawTextHtml(getVal('missions_psig'), true, dangerColor, '1.6em', '0');
            
            htmlContent += drawTitleHtml("5. EXÉCUTION");
            htmlContent += drawTextHtml(getVal('action_body_text'), true, primaryText, '1.4em', '0'); 
            
            htmlContent += drawSubTitleHtml("Chronologie des temps");
            const chronoHeaders = ["Type", "Heure", "Description"];
            const chronoRows = (formData.time_events || []).map(e => [e.type || 'N/A', e.hour || 'N/A', e.description || 'N/A']);
            htmlContent += drawTableHtml(chronoHeaders, chronoRows);

            htmlContent += drawSubTitleHtml("Hypothèses");
            htmlContent += drawTextHtml(`<span style="color: ${dangerColor}; font-weight: bold;">H1</span>: ${getVal('hypothese_h1')}<br><span style="color: ${dangerColor}; font-weight: bold;">H2</span>: ${getVal('hypothese_h2')}<br><span style="color: ${dangerColor}; font-weight: bold;">H3</span>: ${getVal('hypothese_h3')}`, true, primaryText, '1.2em');
            
            htmlContent += await drawImagesHtmlFromCategory('photo_container_transport_pr_preview_container', 'Transport PSIG vers PR');
            htmlContent += await drawImagesHtmlFromCategory('photo_container_transport_domicile_preview_container', 'Transport PR vers Domicile/LE');
            htmlContent += await drawImagesHtmlFromCategory('photo_container_bapteme_terrain_preview_container', 'Baptême terrain');

            htmlContent += drawTitleHtml("6. ARTICULATION (MOIPC/ZMSPCP)");
            htmlContent += drawTextHtml(`Place du Chef (Générale): ${getVal('place_chef')}`, true, primaryText, '1.2em', '0');

            htmlContent += drawSubTitleHtml(`<span style="color: ${accentColor}; font-weight: bold;">Équipe INDIA (INTER)</span>`);
            htmlContent += wrapHtml('<strong style="color: ' + accentColor + ';">Composition:</strong>', 'h4', { 'padding-left': '15px', 'margin-top': '10px', 'font-size': '1.1em' });
            htmlContent += getCompositionHtml('india');
            
            const moipcText = `<p style="padding-left:15px; margin-bottom: 8px;">
                <span style="color: ${dangerColor}; font-weight: bold;">M</span>ission : ${getVal('india_mission')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">O</span>bjectif : ${getVal('india_objectif')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">I</span>tinéraire : ${getVal('india_itineraire')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">P</span>oints Particuliers : ${getVal('india_points_particuliers')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">C</span>onduite à Tenir : ${getVal('india_cat')}
            </p>`;
            htmlContent += moipcText;
            
            htmlContent += await drawImagesHtmlFromCategory('photo_container_itineraire_exterieur_preview_container', 'Itinéraire Extérieur India');
            htmlContent += await drawImagesHtmlFromCategory('photo_container_itineraire_interieur_preview_container', 'Itinéraire Intérieur India');
            htmlContent += await drawImagesHtmlFromCategory('photo_container_cellule_effraction_preview_container', 'Cellule Effraction');

            htmlContent += drawTitleHtml("6. ARTICULATION (Suite)");
            htmlContent += drawSubTitleHtml(`<span style="color: ${accentColor}; font-weight: bold;">Équipe Appui/Observation (AO) - ZMSPCP</span>`);
            htmlContent += wrapHtml('<strong style="color: ' + accentColor + ';">Composition:</strong>', 'h4', { 'padding-left': '15px', 'margin-top': '10px', 'font-size': '1.1em' });
            htmlContent += getCompositionHtml('ao');
            
            const aoText = `<p style="padding-left:15px; margin-bottom: 8px;">
                <span style="color: ${dangerColor}; font-weight: bold;">Z</span>one d'installation : ${getVal('ao_zone_installation')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">M</span>ission : ${getVal('ao_mission')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">S</span>ecteur de surveillance : ${getVal('ao_secteur_surveillance')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">P</span>oints Particuliers : ${getVal('ao_points_particuliers')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">C</span>onduite à Tenir : ${getVal('ao_cat')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">P</span>lace du Chef : ${getVal('ao_place_chef')}
            </p>`;
            htmlContent += aoText;
            
            htmlContent += await drawImagesHtmlFromCategory('photo_container_emplacement_ao_preview_container', 'Emplacement AO');

            htmlContent += drawTitleHtml("7. PATRACDVR (Détail de la Composition)");
            const patracHeaders = ["Trigramme", "Fonction", "Cellule", "Princ.", "Sec.", "A.F.I.", "Grenades", "Équip. 1", "Équip. 2", "Tenue", "GPB"];
            for (const row of (formData.patracdvr_rows || [])) {
                if(row.vehicle && row.members && row.members.length > 0) {
                    htmlContent += drawSubTitleHtml(`Véhicule: ${row.vehicle}`);
                    const patracRows = row.members.filter(m => m.trigramme).map(m => [
                         m.trigramme, m.fonction, m.cellule, 
                         m.principales, m.secondaires, m.afis, m.grenades, 
                         m.equipement, m.equipement2, m.tenue, m.gpb
                    ]);
                    if (patracRows.length > 0) { htmlContent += drawTableHtml(patracHeaders, patracRows); }
                }
            }
            
            htmlContent += drawTitleHtml("9. CONDUITES À TENIR");
            htmlContent += drawSubTitleHtml("Générales"); htmlContent += drawTextHtml(getVal('cat_generales'), true);
            const noGoText = getVal('no_go');
            if (noGoText) {
                htmlContent += drawSubTitleHtml("NO GO");
                htmlContent += drawTextHtml(noGoText, true, dangerColor, '1.2em');
            }
            htmlContent += drawSubTitleHtml("Liaison"); htmlContent += drawTextHtml(getVal('cat_liaison'), true);
            
            htmlContent += `</div>`;
            return htmlContent;
        }
    </script>
</body>
</html>
